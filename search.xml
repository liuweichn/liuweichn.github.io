<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Gradle与Maven的区别]]></title>
    <url>%2F2019%2F12%2F10%2FGradle%E4%B8%8EMaven%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[Java生态体系中3大构建工具：Ant、Maven和Gradle。Ant由Apache软件基金会维护；Maven是Apache下的一个纯Java开发的开源项目，基于项目对象模型；Gradle是基于Ant和Maven概念的自动化构建工具，使用一种基于Groovy的特定领域语言（DSL）来声明项目设置。 经过几年的发展，Ant几乎销声匿迹，而Maven由于较为不灵活的配置也渐渐被遗忘，而由于Gradle是基于Ant和Maven的一个优化版本，被越来越多的开发者使用。 下面简单说下Maven和Gradle区别 依赖管理在Maven的管理体系中，用GroupID、ArtifactID和Version组成的Coordination唯一标识一个依赖项。任何基于Maven构建的项目自身也必须定义前两项属性，不指定Version则使用最新版本。1234567891011&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;version&gt;2.1.10.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt;&lt;/dependencies&gt; Gradle中直接使用“:”连接起来，GroupId:ArtifactId:Version。1234567dependencies &#123; testImplementation &apos;junit:junit:4.12&apos; androidTestImplementation &apos;com.android.support.test:runner:1.0.2&apos; androidTestImplementation &apos;com.android.support.test.espresso:espresso-core:3.0.2&apos; implementation &apos;com.android.support:support-annotations:28.0.0&apos; implementation &apos;com.android.support:appcompat-v7:28.+&apos;&#125; 1、Maven和Gradle对依赖项的审视也有所不同。在Maven中，一个依赖项有6种scope，分别是compile、provided、runtime、test、system、import。其中compile为默认。而gradle将其简化为4种，compile、runtime、testCompile、testRuntime。如上述代码“testCompile ‘junit:junit:4.+’”，在Gradle中支持动态的版本依赖，在版本号后面使用+号可以实现动态的版本管理。2、在解决依赖冲突方面Gradle的实现机制更加明确，两者都采用的是传递性依赖，而如果多个依赖项指向同一个依赖项的不同版本时可能会引起依赖冲突，Maven处理起来较为繁琐，而Gradle先天具有比较明确的策略。3、两者都采用了插件机制，Maven是基于XML进行配置，而在Gradle中更加灵活。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CentOS 安装MySql、Java]]></title>
    <url>%2F2019%2F09%2F13%2FCentOS-%E5%AE%89%E8%A3%85MySql%E3%80%81Java%2F</url>
    <content type="text"><![CDATA[腾讯云99/年买了1M、1G、50G云服务器，安装MySql、Java环境，服务托管于此地。 连接到远程服务器123ssh root@服务器地址或ssh -o serveraliveinterval=60 root@服务器地址 Java环境安装1、查看yum下可更新的Java列表1[root@VM_0_17_centos /]# yum -y list java* 2、安装12[root@VM_0_17_centos /]# yum install -y java-1.8.0-openjdk.x86_64java -version //查看版本 MySql安装下载并安装1、下载并安装MySQL官方的 Yum Repository1[root@localhost ~]# wget -i -c http://dev.mysql.com/get/mysql57-community-release-el7-10.noarch.rpm 2、 使用上面的命令就直接下载了安装用的Yum Repository，大概25KB的样子，然后就可以直接yum安装了1[root@localhost ~]# yum -y install mysql57-community-release-el7-10.noarch.rpm 2、之后就开始安装MySQL服务器。1[root@localhost ~]# yum -y install mysql-community-server 日志12345678910Installed: mysql-community-libs.x86_64 0:5.7.27-1.el7 mysql-community-libs-compat.x86_64 0:5.7.27-1.el7 mysql-community-server.x86_64 0:5.7.27-1.el7 Dependency Installed: mysql-community-client.x86_64 0:5.7.27-1.el7 mysql-community-common.x86_64 0:5.7.27-1.el7 numactl-libs.x86_64 0:2.0.9-7.el7 Replaced: mariadb-libs.x86_64 1:5.5.60-1.el7_5 数据库配置1、启动MySql123[root@localhost ~]# systemctl start mysqld.service``` 2、查看MySql运行状态 [root@localhost ~]# systemctl status mysqld.service13、此时MySQL已经开始正常运行，不过要想进入MySQL还得先找出此时root用户的密码，通过如下命令可以在日志文件中找出密码 [root@localhost ~]# grep “password” /var/log/mysqld.log12![查看密码](CentOs-安装MySql、Java/password.png)4、进入数据库 mysql -uroot -p密码12输入密码 5、修改初始密码 mysql&gt; ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘new password’;ERROR 1819 (HY000): Your password does not satisfy the current policy requirements//密码不满足规则，可查看规则12```show variables like &apos;validate_password%&apos;;//查看规则 常用命令1、查看内存使用情况1free -mh 2、查看硬盘使用情况12dfdf -h Mac使用scp指令上传文件到CentOs打开终端进入要上传文件的目录下，使用scp指令上传文件12345上传： scp first-0.0.1-SNAPSHOT.jar root@远程服务器ip地址:~ //根目录scp first-0.0.1-SNAPSHOT.jar root@远程服务器ip地址:/root/myapp/first.jar //复制到myapp文件夹下下载： scp root@远程服务器ip地址:/下载文件的目录 『空格』 本地目录 后台运行java程序1nohup java -jar first.jar 杀死nohup提交的后台运行的程序1231.如果没有退出客户端界面，可以先通过 “jobs” 命令查看程序是否在运行，此时只有序号没有PID号； 2.输入命令 “jobs -l” 会显示程序的PID号，然后通过 “kill -9 PID”杀死程序； 3.输入命令 “jobs” 查看程序是否被杀死。 1231.如果退出过客户端界面，输入 “jobs” 命令查不到正在运行的程序； 2.输入 “ps ux” 来查看所有程序的进程号PID，然后再通过 “kill -9 PID” 杀死程序； 3.输入 “ps ux” 来查看程序是否被杀死。 Linux常用命令.ls -la 查看当前目录下的文件夹及文件.rm -fr file/dir 删除文件或文件夹]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>CentOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot测试打包发布]]></title>
    <url>%2F2019%2F09%2F12%2FSpring-Boot%E6%B5%8B%E8%AF%95%E6%89%93%E5%8C%85%E5%8F%91%E5%B8%83%2F</url>
    <content type="text"><![CDATA[开发阶段就需要进行单元测试，Spring Boot对单元测试支持完善。在 test 文件夹先新建一个测试类 UserControllerTest添加@RunWith(SpringRunner.class)和@SpringBootTest注解，然后在测试方法头部加 @Test即可，最后在方法或类上右键run运行 测试12345678910111213141516@RunWith(SpringRunner.class)@SpringBootTestpublic class UserControllerTest &#123; @Autowired private UserController1 userController1; @Test public void hello()&#123; Iterable&lt;User&gt; allUser = userController1.getAllUser(); for (User user : allUser) &#123; System.out.println(user.toString()); &#125; &#125;&#125; 打包1gradle build *会在项目 build -&gt; libs 目录下生成 first-0.0.1-SNAPSHOT.jar 文件 发布进入libs目录下，运行1java -jar first-0.0.1-SNAPSHOT.jar]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot Jpa的使用]]></title>
    <url>%2F2019%2F09%2F12%2FSpring-boot-Jpa%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Jpa（Java Persistence API）是Sun官方提出的Java持久化规范，提供一种对象/关系映射工具管理Java应用中的关系数据，为简化持久化开发工作和整合ORM技术。 注意Jpa是一套规范，不是一套产品。Hibernate、TopLink、JDO等框架是一套产品，如果这些产品实现了这个规范，那么我们就可以加他们为Jpa的实现产品。 Spring Boot Jpa是Spring 基于ORM框架、Jpa规范的基础上封装的一套Jpa应用框架，可使开发者用极简单的代码即可实现对数据的访问操作。它提供包括增删改查等在内的常用操作，且易于扩展！Spring Boot Jpa可以极大的提高开发效率。 在之前的文章Spring Boot MySql操作简单使用Spring Boot Jpa功能，此篇详细介绍常用用法及注意事项。12userRepository.save(user); //插入userRepository.findAll(); //查询所有 基本查询基本查询也分为两种，一种是 Spring Data 默认已经实现，一种是根据查询的方法来自动解析成 SQL。 预先生成方法Spring Boot Jpa预生成了一些基本的CURD方法（增删改查）等等 继承 JpaRepository123public interface UserRepository extends JpaRepository&lt;User, Long&gt; &#123;&#125; 使用默认方法1234567891011121314151617public class UserController1 &#123; @Autowired private UserRepository userRepository;//自动注入生成的对象，逻辑处理层 @PostMapping(path = &quot;/test&quot;) public @ResponseBody String addNewUser(@RequestParam String name, @RequestParam String email) &#123; userRepository.save(user); userRepository.finidAll(); userRepository.findOne(1); userRepository.delete(user); userRepository.count(); userRepository.exists(1); return &quot;test&quot;; &#125; 123delete时需要加上注解： @Modifying@Transactional 自定义简单查询根据方法名来自动生成Sql，主要语法有：findXXBy、readAXXBy、queryXXBy、countXXBy、getXXBy后面更属性名称123Iterable&lt;User&gt; findByEmail(String email);//根据email查Iterable&lt;User&gt; findByNameOrEmail(String name,String email);//根据name或者email查Long deleteByName(String name);//根据name删除 LIKE、OrderBy、IgnoreCase等Sql体系的关键词都可以使用 Keyword Sample JPQL snippet And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 Between findByStartDateBetween … where x.startDate between ?1 and ?2 LessThan findByAgeLessThan … where x.age &lt; ?1 LessThanEqual findByAgeLessThanEqual … where x.age &lt;= ?1 GreaterThan findByAgeGreaterThan … where x.age &gt; ?1 GreaterThanEqual findByAgeGreaterThanEqual … where x.age &gt;= ?1 After findByStartDateAfter … where x.startDate &gt; ?1 Before findByStartDateBefore … where x.startDate &lt; ?1 IsNull findByAgeIsNull … where x.age is null IsNotNull,NotNull findByAge(Is)NotNull … where x.age not null Like findByFirstnameLike … where x.firstname like ?1 NotLike findByFirstnameNotLike … where x.firstname not like ?1 StartingWith findByFirstnameStartingWith … where x.firstname like ?1 (parameter bound with appended %) EndingWith findByFirstnameEndingWith … where x.firstname like ?1 (parameter bound with prepended %) Containing findByFirstnameContaining … where x.firstname like ?1 (parameter bound wrapped in %) OrderBy findByAgeOrderByLastnameDesc … where x.age = ? order by x.lastname desc Not findByLastnameNot … where x.lastname &lt;&gt; ?1 In findByAgeIn(Collection ages) … where x.age in ? NotIn findByAgeNotIn(Collection age) … where x.age not in ?1 TRUE findByActiveTrue() … where x.active = true IgnoreCase findByFirstnameIgnoreCase … where UPPER(x.firstame) = UPPER(?1) 复杂查询在实际开发中我们需要用到分页、删选、连表等查询时就需要特殊的方式或者自定义Sql 分页查询Spring Boot Jpa已经帮我们实现了分页功能，在查询的时候传入Pageable，当查询中有多个参数时Pageable建议作为做后一个参数传入。12Page&lt;User&gt; findALL(Pageable pageable);Page&lt;User&gt; findByName(String name,Pageable pageable); Pageable是spring封装的分页实现类，使用的时候需要传入页数、每页条数和排序规则123456@PostMapping(path = &quot;/findByPage&quot;)public @ResponseBody Page&lt;User&gt; findAllByPage(@RequestParam int page,@RequestParam int size)&#123; Sort sort = new Sort(Sort.Direction.ASC, &quot;id&quot;); Pageable pageable = PageRequest.of(page,size,sort); return userRepository.findAll(pageable);&#125; 返回结果123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&#123; &quot;content&quot;: [ &#123; &quot;id&quot;: 10, &quot;name&quot;: &quot;wang&quot;, &quot;email&quot;: &quot;345@126.com&quot; &#125;, &#123; &quot;id&quot;: 4, &quot;name&quot;: &quot;liuwei&quot;, &quot;email&quot;: &quot;liuwei_chn@126.com&quot; &#125;, &#123; &quot;id&quot;: 9, &quot;name&quot;: &quot;wang&quot;, &quot;email&quot;: &quot;34@126.com&quot; &#125;, &#123; &quot;id&quot;: 8, &quot;name&quot;: &quot;wang&quot;, &quot;email&quot;: &quot;3@126.com&quot; &#125;, &#123; &quot;id&quot;: 11, &quot;name&quot;: &quot;wang&quot;, &quot;email&quot;: &quot;3456@126.com&quot; &#125; ], &quot;pageable&quot;: &#123; &quot;sort&quot;: &#123; &quot;sorted&quot;: false, &quot;unsorted&quot;: true, &quot;empty&quot;: true &#125;, &quot;offset&quot;: 0, &quot;pageSize&quot;: 5, &quot;pageNumber&quot;: 0, &quot;unpaged&quot;: false, &quot;paged&quot;: true &#125;, &quot;totalPages&quot;: 4, &quot;totalElements&quot;: 17, &quot;last&quot;: false, &quot;size&quot;: 5, &quot;number&quot;: 0, &quot;first&quot;: true, &quot;numberOfElements&quot;: 5, &quot;sort&quot;: &#123; &quot;sorted&quot;: false, &quot;unsorted&quot;: true, &quot;empty&quot;: true &#125;, &quot;empty&quot;: false&#125; 限制查询取前N个数据:top10（queryFirst10ByName）123456789//按名字查前10条记录，根据id正序Iterable&lt;User&gt; findFirst10ByName(String name, Sort sort);//限制查询@GetMapping(path = &quot;/nameTop10&quot;)public @ResponseBody Iterable&lt;User&gt; top10(@RequestParam String name)&#123; Sort sort = new Sort(Sort.Direction.ASC,&quot;id&quot;); return userRepository.findFirst10ByName(name,sort);&#125; 12//After 根据packageName并且status &gt; 0 查询Build findFirstByPackageNameAndStatusAfter(String packageName, int than, Sort sort); 自定义Sql查询Spring Boot Jpa支持sql语句查询。查询方法使用@Query注解；修改/删除使用@Modifying；也可以@Transactional对事务的支持，设置查询超时1234567891011//自定义sql查询@Query(&quot;select u from User u where u.name=?1&quot;)Iterable&lt;User&gt; findByName(String name);@Modifying@Query(&quot;update User u set u.name = ?1 where u.id = ?2&quot;)int modifyNameById(String name,Integer id);@Modifying@Query(&quot;delete from User where id = ?1&quot;)void deleteById(Integer id); 1234567891011121314151617181920@PostMapping(path = &quot;/findByName&quot;)public @ResponseBody Iterable&lt;User&gt; findByName(@RequestParam String name)&#123; return userRepository.findByName(name);&#125;@Modifying@Transactional@PostMapping(path = &quot;/updateNameById&quot;)public @ResponseBodyint updateNameById(@RequestParam String name, @RequestParam Integer id) &#123; return userRepository.modifyNameById(name, id);&#125;@Modifying@Transactional@PostMapping(path = &quot;/deleteById&quot;)public @ResponseBody String deleteById(@RequestParam Integer id)&#123; userRepository.deleteById(id); return &quot;删除成功&quot;;&#125; 多表查询待补充 多数据源的支持待补充]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot MySql操作]]></title>
    <url>%2F2019%2F09%2F12%2FSpring-Boot-MySql%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[之前初始化项目时加入了mysql数据库依赖 添加配置文件 编辑resources -&gt; application.properties 文件12345# mysqlspring.jpa.hibernate.ddl-auto=createspring.datasource.url=jdbc:mysql://127.0.0.1:3306/db_examplespring.datasource.username=rootspring.datasource.password=root 123456781.spring.jpa.hibernate.ddl-auto=createcreate： 每次加载hibernate时都会上一次生成的表，然后根据你的model类再生成新表，会导致数据丢失；create-drop：每次加载hibernate时根据model类生成表，但是sessionFactory一关闭表就自动删除；update：最常用的属性，第一次夹在hibernate时根据model类会自动建立表的结构（前提是先建立好数据库），以后根据model类自动更新表结构，即使表结构改变了但表中的行仍然存在不会删除以前的行；validate：每次加载hibernate时，验证创建数据库表结构，只会在数据库中的表进行比较，不会创建新表，但是会插入新值。2.spring.datasource.url=jdbc:mysql://127.0.0.1:3306/db_example新建‘db_example’数据库3.4. root 添加实体类123456789101112131415@Entitypublic class User &#123; @Id @GeneratedValue(strategy = GenerationType.AUTO) private Integer id; @Column(nullable = false) private String name; @Column(nullable = false, unique = true) private String email; //省略getter setter方法&#125; Dao层1234public interface UserRepository extends JpaRepository&lt;User,Long&gt; &#123;&#125;//JpaRepository 里面实现了大量的增删改查方法 UserController123456789101112131415161718192021222324252627@Controller@RequestMapping(&quot;/user&quot;)public class UserController &#123; @Autowired private UserRepository userRepository;//自动注入生成的对象，逻辑处理层 /** * 新增用户 */ @PostMapping(path = &quot;/add&quot;) public @ResponseBody String addNewUser(@RequestParam String name, @RequestParam String email) &#123; User user = new User(); user.setName(name); user.setEmail(email); userRepository.save(user); return &quot;Saved&quot;; &#125; @GetMapping(path = &quot;/getAll&quot;) public @ResponseBody Iterable&lt;User&gt; getAllUser() &#123; return userRepository.findAll(); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gradle 初始化Spring boot项目]]></title>
    <url>%2F2019%2F09%2F11%2FGradle-%E5%88%9D%E5%A7%8B%E5%8C%96Spring-boot%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[1、网页构建https://start.spring.io 初始化gradle spring boot IntelliJ IDEA中打开项目 2、IDEA Gradle构建打开Idea -&gt; new Project -&gt; Spring Initializr -&gt; Type选择Gradle Project -&gt; 填写group、artifact -&gt; 钩上web、jpa、mysql -&gt; 点下一步就行了。]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac 8080端口被占用]]></title>
    <url>%2F2019%2F09%2F11%2Fmac-8080%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%2F</url>
    <content type="text"><![CDATA[当端口被占用后,我们可以使用下面这个命令去查看哪个程序占用了端口1234lsof -i tcp:8080``` 然后对其中的pid执行这个命令 kill 12334 (12334 指的是pid)12345&lt;!-- more --&gt;但有时候发现杀掉了,端口还是被占用了.则使用该命令 sudo lsof -i :80801然后根据端PID去杀掉对应的进程: sudo kill -9 61342`]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>8080端口占用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 基本数据类型]]></title>
    <url>%2F2019%2F05%2F17%2FKotlin-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"></content>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 基础语法]]></title>
    <url>%2F2019%2F05%2F10%2FKotlin-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[函数定义；可变长参数函数；lambda（匿名函数）；常量变量；注释；字符串模版；NULL检查机制；类型检测及自动转换；区间 函数定义关键字fun，参数格式为：参数：类型1234567891011fun sum(a: Int, b: Int): Int &#123; return a + b&#125;//表达式作为函数体fun sum1(a: Int, b: Int): Int = a + b//无返回值的函数： Unitfun PrintSum(a: Int): Unit &#123; print(a)&#125; 可变长度参数关键字：vararg1234fun vars(vararg v: String) &#123; for(vt in v) print(vt)&#125; lambad（匿名函数）1234fun lambadDemo()&#123; val sumLambad: (Int, Int) -&gt; Int = &#123;x, y -&gt; x + y&#125; print(sumLambad(2, 3)) //输出5&#125; 定义变量常量var 关键字 //变量var &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;1var a : Int = 1 val 关键字 //常量val &lt;标识符&gt; : &lt;类型&gt; = &lt;初始化值&gt;1val a : Int = 1 注释单行注视1//这是单行注视 多行注释123/* 这是 多行注释*/ 字符串模版$ 表示一个变量名或变量值$varName 表示变量值${varName.fun()} 表示变量的方法返回值1234567891011var a = 1//模版中的简单名称val s1 = &quot;a is $a&quot;a = 2//模版中的任意表达式val s2 = &quot;$&#123;s1.replace(&quot;is&quot;,&quot;was&quot;)&#125;, but now is $a&quot;//输出： a was 1, but now is 2 NULL检查机制Kotlin的空安全设计对于声明可为空的参数，在使用时要进行空判断处理，有两种处理方式，字段后加 !! 像java一样抛出空异常，另一种字段后加 ? 可不做处理返回值为null或配合 ?: 作空判断处理123456789101112//类型后面加 ? 表示可为空var age: String? = &quot;23&quot;age = null//抛出空指针异常val ages = age!!.toInt()//不做处理返回nullval age1 = age?.toInt()//为空返回-1val age2 = age?.toInt() ?: -1 类型检测及自动类型转换使用 is 运算符检测是否为某种类型（类似于java的instanceof关键字）123456789101112fun getStrLength(obj: Any): Int?&#123; if(obj is String) return obj.length return null&#125;//或者 !isfun getStrLength(obj: Any): Int?&#123; if(obj !is String) return null //这个分支中，obj 会被自动转换为 String return obj.length&#125; 区间区间表达式由具有操作符 .. 的范围形式辅以in组合；区间是为任何可比较类型定义的。1234for(i in 1..4) print(i) //输出1234for(i in 4 downTo 1) print(i) //输出4321for(i in 1..4 step 2) print(i) //输出13，步长为2for(i in 1 until 4) print(i) //输出123，[1,4)含左不含右]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin 教程]]></title>
    <url>%2F2019%2F05%2F10%2FKotlin-%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Kotlin是一种在Java虚拟机上运行的静态类型编程语言，被称之为Android界的Swift。由JetBrains设计开发。Kotlin可以编译成Java字节码，也可以编译成JavaScript，方便在没有Java的设备上运行。Google在 I/O 2017年，宣布成为Android官方开发语言。 Kotlin Android 环境搭建打开setting，在plugins中搜索kotlin安装 将Java代码转换为Kotlin新建一个Android项目，添加一个磨人的MainActivity打开MainActivity.java文件，通过菜单栏依次调出Code-&gt;Convert Java File to Kotlin File转换完成后可看到使用Kotlin编写的activity 工程配置Kotlin转换完之后Android Strdio会提示当前工程还未配置Kotlin，根据提示完成操作即可]]></content>
      <categories>
        <category>Kotlin</category>
      </categories>
      <tags>
        <tag>Kotlin</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot(2)-Web综合开发]]></title>
    <url>%2F2019%2F04%2F29%2FSpring-Boot-2-Web%E7%BB%BC%E5%90%88%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[Web开发： 包括常用的json输出、filters、property、log等 1.json接口开发使用@Controller注解即可返回json数据12345678910@RestControllerpublic class HelloController &#123; @RequestMapping(&quot;/getUser&quot;) public User getUser() &#123; User user=new User(); user.setUserName(&quot;小明&quot;); user.setPassWord(&quot;xxxx&quot;); return user; &#125;&#125; 请求返回：1&#123;&quot;name&quot;:&quot;小明&quot;,&quot;password&quot;:xxxx&#125; 2.自定义Filter使用filter记录日志: 实现Filter接口 添加@Configuration注解，将自定义Filter加入过滤器12345678910111213141516171819202122232425262728293031323334353637383940@Configurationpublic class WebConfiguration &#123; @Bean public RemoteIpFilter remoteIpFilter() &#123; return new RemoteIpFilter(); &#125; @Bean public FilterRegistrationBean testFilterRegistration() &#123; FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new MyFilter()); registration.addUrlPatterns(&quot;/*&quot;); registration.addInitParameter(&quot;paramName&quot;, &quot;paramValue&quot;); registration.setName(&quot;MyFilter&quot;); registration.setOrder(1); return registration; &#125; public class MyFilter implements Filter &#123; @Override public void destroy() &#123; // TODO Auto-generated method stub &#125; @Override public void doFilter(ServletRequest srequest, ServletResponse sresponse, FilterChain filterChain) throws IOException, ServletException &#123; // TODO Auto-generated method stub HttpServletRequest request = (HttpServletRequest) srequest; System.out.println(&quot;this is MyFilter,url :&quot;+request.getRequestURI()); filterChain.doFilter(srequest, sresponse); &#125; @Override public void init(FilterConfig arg0) throws ServletException &#123; // TODO Auto-generated method stub &#125; &#125;&#125; 3.自定义Property开发中经常需要自定义一些配置文件。 1.配置在application.properties中12user.name=小明user.age=26 获取配置信息12@Value(&quot;$&#123;user.name&#125;&quot;)private String name; 2.配置在其他文件中user.properties在main/resources下新建user.properties文件12haha.name=小明haha.age=260 获取配置信息12345678910111213141516171819202122232425262728293031323334@Component//@ConfigurationProperties(prefix = &quot;user&quot;)@PropertySource(value = &quot;classpath:user.properties&quot;,encoding = &quot;UTF-8&quot;)public class UserBean &#123; @Value(&quot;$&#123;user.user.name&#125;&quot;) private String name; @Value(&quot;$&#123;user.user.age&#125;&quot;) private int age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;name=&apos;&quot; + name + &apos;\&apos;&apos; + &quot;, age=&quot; + age + &apos;&#125;&apos;; &#125;&#125; @PropertySource：value = “classpath:user.properties”自定义properties位置 encoding = “UTF-8”编码（不设置可能会中文乱码）]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Boot（1）-入门]]></title>
    <url>%2F2019%2F04%2F29%2FSpring-Boot-1-%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。用我的话来理解，就是 Spring Boot 其实不是什么新的框架，它默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。 1.引入maven引入：打开pom.xml123456789101112131415161718192021222324252627282930313233&lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt;&lt;/properties&gt;&lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;&lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; spring boot建议目录结构 123456789101112131415com +- example +- myproject +- Application.java //根目录，主要用于做一些框架配置 | +- domain //实体（Entity）与数据访问层（Repository） | +- Customer.java | +- CustomerRepository.java | +- service //业务类代码 | +- CustomerService.java | +- controller //页面访问控制 | +- CustomerController.java | 2.引入web模块中加入spring-boot-starter-web12345678&lt;dependencies&gt;... &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt;...&lt;dependencies&gt; pom.xml中默认两个模块. spring-boot-starter:核心模块，包括自动配置支持、日志和YAML，如果引入了spring-boot-starter-web模块，可以去到此配置，因为spring-boot-starter-web自动依赖spring-boot-starter。 spring-boot-starter-test 3.Hello World新建controller/HelloWorldController.java1234567@RestControllerpublic class HelloWorldController &#123; @RequestMapping(&quot;/hello&quot;) public String index() &#123; return &quot;Hello World&quot;; &#125;&#125; 启动FirstApplication 参考：http://www.ityouknow.com/springboot/2016/01/06/spring-boot-quick-start.html]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Maven 安装与配置]]></title>
    <url>%2F2019%2F04%2F28%2FMaven-%E5%AE%89%E8%A3%85%E4%B8%8E%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[Maven项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建，报告和文档的项目管理工具软件。 Maven是一个项目管理和综合工具。Maven提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven使用标准的目录结构和默认构建生命周期。 在多个开发团队环境时，Maven可以设置按标准在非常短的时间里完成配置工作。由于大部分项目的设置都很简单，并且可重复使用，Maven让开发人员的工作更轻松，同时创建报表，检查，构建和测试自动化设置。 1.下载maven包下载地址http://maven.apache.org/download.cgi 注意Binary tar.gz archive：是装在Linux、MacOsX上的Binary zip archive：是装在windows上的binary表示编译后的二进制文件，一般比较小，适合直接在项目中使用source表示可以查看源代码的，比binary大一些，如果你想看一下maven的源码可以下载这一类的 2.mac下 maven环境配置1.先解压Binary tar.gz archive文件2.打开配置文件:open ~/.bash_profile3.最后面加入环境配置：12export MAVEN_HOME=/Users/pc/apache-maven-3.6.1export PATH=$PATH:$MAVEN_HOME/bin 4.使配置生效1source .bash_profile]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Intellij IDEA安装]]></title>
    <url>%2F2019%2F04%2F28%2FIntellij-IDEA%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[IDEA 全称 IntelliJ IDEA，是java编程语言开发的集成环境。IntelliJ在业界被公认为最好的java开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE支持、各类版本工具(git、svn等)、JUnit、CVS整合、代码分析、 创新的GUI设计等方面的功能可以说是超常的。 1.下载https://www.jetbrains.com/idea/ 2.安装略 3.激活注册码:http://idea.lanyus.com获取注册码用于激活]]></content>
      <tags>
        <tag>IntelliJ IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dagger2 - 进阶]]></title>
    <url>%2F2018%2F05%2F18%2FDagger2%20-%20%E8%BF%9B%E9%98%B6%2F</url>
    <content type="text"><![CDATA[Dagger2 - 基础 讲解了Inject，Component，Module，Provides是如何构成Dagger2整个依赖注入框架。本章讲解Qualifier（限定符），Singleton（单例），Scope（作用域），SubComponent，对Dagger2进行细节上的完善。 Qualifier（限定符）]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android 第三方框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Dagger2 - 基础]]></title>
    <url>%2F2018%2F05%2F18%2FDagger2%20-%20%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[Dagger2,它是解决android或java中依赖注入的一个类库（DI类库）。Dagger2能带来哪些好处？Dagger2中的Inject，Component，Module，Provides等等是什么，有什么作用？Dagger2如何使用？ 准备依赖注入： 就是目标类（目标类需要进行依赖初始化的类）中所依赖的其他类的初始化过程，不是通过手动编码的方式创建，而是通过技术手段可以吧其他的类的已经初始化好了的实例自动注入到目标类中。 正式开始Inject先看一段代码123456class A&#123; B b = new B(...); C c = new C(); D d = new D(new E()); F f = new F(.....);&#125; 上面代码在做重复工作，new B() new C()… 我们可以用注解来标注目标类中所依赖的其他类，同样用注解来标注所依赖的其他类的构造函数，那注解的名字就叫Inject12345678910class A&#123; @Inject B b;&#125;class B&#123; @Inject public B()&#123; &#125;&#125; 这样我们就可以让目标类中所依赖的其他类与其他类的构造函数有一种联系。Component就是他们联系的桥梁。 ComponentComponent也是一个注解类，一个类要想是Component，必须用Component注解来标注该类，并且该类是抽象类或接口。Component是目标类所依赖的其他类和其他类的构造函数直接的桥梁，那么Component需要引用到目标类的实例，Component会查找目标类中用Inject注解标注的属性，查找到相应的属性后会接着查找该属性对应的用Inject标注的构造函数（此时就发生了联系），剩下的工作就是初始化该属性的实例并把实例进行赋值。因此我们也可以给Component就另一个名字注入器（Injector）。 小结目标类要想初始化自己所依赖的其他类： 用Inject注解标注目标类的其他类 用Inject注解标注其他类的构造函数（若其他类还依赖于别的类，重复1 2步骤） 调用Component（注入器）的injectXXX（Object）方法开始注入（injectXXX方法名字是官方推荐的名字，以inject开始） Component现在是一个注入器，Component会把目标类依赖的实例注入到目标类中，并初始化目标类的依赖。 为啥又有个Module如果项目中用到第三方的类库，就不能修改第三方类库，所以不可能把Inject注解加入到这些类中，此时Inject就失效了。 那我们怎么封装第三方类库呢，于是Module就派上用场了。可以把封装第三方类库的代码放到Module中：1234567@Modulepublic class ModuleClass&#123; //A是第三方类库中的一个类 A provideA()&#123; return A(); &#125;&#125; Module其实是一个简单工厂模式，Module里面的方法基本都是创建类实例的方法。问题：Component注入器，如何让Component与Module产生联系？ Component新职责Component是注入器，它一端连接目标类，另一端连接目标类的依赖实例，它把目标类实例注入到目标类中。上文中的Module是一个提供类实例的类，所有它是属于Component的实例端的，Component的新职责是管理Module，Component中的modules属性可以把Module加入到Component中，modules可以加入多个Module。 Provides 最终解决第三方类库依赖注入问题Module中创建类实例方法用Provides进行标注，Component在搜索到目标类中用Inject注解标注的属性后，Component就会去Module中查找用Provides标注的对应的创建类实例方法，这样就解决了第三方类库用Dagger2实现依赖注入了。 总结Inject，Component，Module，Provides是Dagger2中最基础最核心的内容。奠定了Dagger2的整个依赖注入框架。 Inject用于标注目标类的依赖，和依赖的构造函数 Component是个桥梁，连接目标类和目标类的依赖的实例，它也是注入器负责把目标类的依赖的实例注入到目标类中，同时管理Module。 Module和Provides是为了解决第三方类库而生的，Module是一个简单工厂模式，Module可以包含创建类实例的方法，这些方法用Provides来标注]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android 第三方框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多渠道打包]]></title>
    <url>%2F2018%2F05%2F08%2F%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[1.多渠道打包（gradle）1.替换channel1.在AndroidManifest.xml中添加占位符(友盟统计渠道)123&lt;meta-data android:name=&quot;MTA_CHANNEL&quot; android:value=&quot;$&#123;MTA_CHANNEL_VALUE&#125;&quot; /&gt; 2.在app的build.gradle中添加代码1234567891011android &#123; productFlavors &#123;//需要哪些渠道都写进来 baidu &#123;&#125; _91 &#123;&#125;//不可使用数字开头 wandoujia &#123;&#125; xiaomi &#123;&#125; &#125; //批量处理 productFlavors.all &#123;//替换在AndroidManifest.xml中的$&#123;MTA_CHANNEL_VALUE&#125; flavor -&gt; flavor.manifestPlaceholders = [MTA_CHANNEL_VALUE: name] &#125; 3.打包build -&gt; Generate Signed APK打出来的包位置 2.更改包名当需要更改包名，在productFlavors中指定不同的applicationId即可123456789101112131415161718productFlavors &#123; baidu &#123; applicationId=&quot;com.aimerd.channel.baidu&quot; &#125; _91 &#123; applicationId=&quot;com.aimerd.channel.jiuyi&quot; &#125; wandoujia &#123; applicationId=&quot;com.aimerd.channel.wandoujia&quot; &#125; xiaomi &#123; applicationId=&quot;com.aimerd.channel.xiaomi&quot; &#125;&#125;// 批量处理productFlavors.all &#123; flavor -&gt; flavor.manifestPlaceholders = [MTA_CHANNEL_VALUE: name]&#125; 3.生成不同应用名称和图标我们以baidu为例，在app模块src目录下，新建一个”baidu”目录（名字和productFlavors中定义的要一致）目录结构如果需要换图标，只需更换ic_launcher.png文件即可。 把values下strings.xml中的”app_name”改成自己想要的应用名称。123&lt;resources&gt; &lt;string name=&quot;app_name&quot;&gt;Dragger2_baidu&lt;/string&gt;&lt;/resources&gt; 2.多渠道打包（美团替换文件）引用 美团Android自动化之旅—生成渠道包 https://tech.meituan.com/mt-apk-packaging.html 工具包及使用 https://gitee.com/welau/multichannel_packaging_channel 复制ChannelUtils到项目中12String aDefault = ChannelUtils.getChannel(this);Toast.makeText(this,aDefault,Toast.LENGTH_SHORT).show();//即可获取到channel]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android 打包</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[robolectric-测试]]></title>
    <url>%2F2018%2F05%2F08%2Frobolectric-%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[robolectric的最大特别是运行测试程序时不需要设备或者模拟器，在电脑中进行就可以了，自然测试程序的运行效率可以大大提升。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Robolectric 测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 屏幕适配]]></title>
    <url>%2F2018%2F05%2F06%2FAndroid-%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[dp适配 参考：ScreenMatch屏幕适配]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Android 图片加载框架]]></title>
    <url>%2F2018%2F04%2F23%2FAndroid-%E5%9B%BE%E7%89%87%E5%8A%A0%E8%BD%BD%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[三大图片加载框架 Picasso Glide Fresco PicassoPicasso：和Square的网络库一起能发挥最大作用，因为Picasso可以选择将网络请求的缓存部分交给okhttp实现。1234Picasso.with(this) .load(&quot;url&quot;) .placeholder(R.mipmap.ic_default) .into(imageView); Glide：对Picasso进行包装，而且在他的基础上加了很多的扩展（gif、video等支持）123Glide.with(fragment) .load(url) .into(imageView); Fresco：最大的优势在于5.0以下的bitmap的加载。在5.0以下，Fresco将图片放到一个特别的内存区域（Ashmem区），5.0以上系统默认就是存储在Ashmem区。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[SmartRefreshLayout 刷新加载数据（listview，recycleview，webivew...）]]></title>
    <url>%2F2018%2F04%2F12%2FSmartRefreshLayout-%E5%88%B7%E6%96%B0%E5%8A%A0%E8%BD%BD%E6%95%B0%E6%8D%AE%EF%BC%88listview%EF%BC%8Crecycleview%EF%BC%8Cwebivew-%EF%BC%89%2F</url>
    <content type="text"><![CDATA[引用 SmartRefreshLayout 前言正如名字所说，SmartRefreshLayout是一个“聪明”或者“智能”的下拉刷新布局，由于它的“智能”，它不只是支持所有的View，还支持多层嵌套的视图结构。它继承自ViewGroup 而不是FrameLayout或LinearLayout，提高了性能。 也吸取了现在流行的各种刷新布局的优点，包括谷歌官方的 SwipeRefreshLayout，其他第三方的 Ultra-Pull-To-Refresh、TwinklingRefreshLayout 。还集成了各种炫酷的 Header 和 Footer。 SmartRefreshLayout的目标是打造一个强大，稳定，成熟的下拉刷新框架，并集成各种的炫酷、多样、实用、美观的Header和Footer。 功能特点 支持多点触摸 支持淘宝二楼和二级刷新 支持嵌套多层的视图结构 Layout (LinearLayout,FrameLayout…) 支持所有的 View（AbsListView、RecyclerView、WebView….View） 支持自定义并且已经集成了很多炫酷的 Header 和 Footer. 支持和ListView的无缝同步滚动 和 CoordinatorLayout 的嵌套滚动 . 支持自动刷新、自动上拉加载（自动检测列表惯性滚动到底部，而不用手动上拉）. 支持自定义回弹动画的插值器，实现各种炫酷的动画效果. 支持设置主题来适配任何场景的App，不会出现炫酷但很尴尬的情况. 支持设多种滑动方式：平移、拉伸、背后固定、顶层固定、全屏 支持所有可滚动视图的越界回弹 使用导包12compile &apos;com.scwang.smartrefresh:SmartRefreshLayout:1.1.0-alpha-3&apos;compile &apos;com.scwang.smartrefresh:SmartRefreshHeader:1.1.0-alpha-3&apos;//没有使用特殊Header，可以不加这行 xml123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;com.scwang.smartrefresh.layout.SmartRefreshLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:id=&quot;@+id/refreshLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recyclerView&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:overScrollMode=&quot;never&quot; android:background=&quot;#fff&quot; /&gt;&lt;/com.scwang.smartrefresh.layout.SmartRefreshLayout&gt; java代码1234567891011121314151617181920212223242526RefreshLayout refreshLayout = (RefreshLayout)findViewById(R.id.refreshLayout);refreshLayout.setOnRefreshListener(new OnRefreshListener() &#123; @Override public void onRefresh(RefreshLayout refreshlayout) &#123; new Handler() &#123; &#125;.postDelayed(new Runnable() &#123; @Override public void run() &#123; refreshLayout.finishRefresh(); &#125; &#125;, 2000); &#125;&#125;);refreshLayout.setOnLoadMoreListener(new OnLoadMoreListener() &#123; @Override public void onLoadMore(RefreshLayout refreshlayout) &#123; new Handler() &#123; &#125;.postDelayed(new Runnable() &#123; @Override public void run() &#123; refreshLayout.finishLoadMore(); //adapter.update(getList()); &#125; &#125;, 2000); &#125;&#125;); 属性设置属性设置1234refreshLayout.setPrimaryColorsId(R.color.colorPrimary, android.R.color.white);//颜色设置refreshLayout.setDragRate(0.5f);//阻尼效果refreshLayout.setHeaderHeight(60);//Header高度dprefreshLayout.setFooterHeight(40);//Footer高度dp Header Footer 设置12345//设置指定的 Header 和 Footer//设置 Header 为 贝塞尔雷达 样式refreshLayout.setRefreshHeader(new ClassicsHeader(this).setTimeFormat(new SimpleDateFormat(&quot;上次更新 HH:mm:ss&quot;)));//设置 Footer 为 球脉冲 样式refreshLayout.setRefreshFooter(new BallPulseFooter(this)); 效果]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android 第三方框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[EventBus 使用]]></title>
    <url>%2F2018%2F03%2F06%2FEventBus-%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[介绍EventBus是一款针对Android优化的发布/订阅事件总线。简化了应用程序内各组件间、组件与后台线程间的通信。优点是开销小，代码更优雅，以及将发送者和接收者解耦。如果Activity和Activity进行交互还好说，如果Fragment和Fragment进行交互着实令人头疼，我们会使用广播来处理，但是使用广播稍显麻烦并且效率也不高，如果传递的数据是实体类需要序列化，那么很显然成本会有点高。今天我们就来学习下EventBus3.0的使用方法。 EventBus的三要素 Event:事件，可以是任意类型的对象 Subscriber:事件订阅者，事件处理的方法可以随便命名，需要价格注解@Subscribe,并且要指定线程模型（默认为POSTING） Publisher：事件发布者，EventBus.getDefault().post() EventBus的5种ThreadMode(线程模型) POSTING(默认)：事件在哪个线程发出，事件就在哪个线程处理 MAIN：事件处理会在UI线程中执行。事件处理时间不能太长（ANR），阻塞式 MAIN_ORDERED:事件处理会在UI线程中执行,非阻塞式 BACKGROUND:事件发出在UI线程时，处理在新线程中运行；事件发出在子线程，处理在该子线程 AYSNC:无论事件在哪个线程发出，处理都会在新建的子线程中运行 EventBus基本用法 导包 1compile &apos;org.greenrobot:eventbus:3.1.1&apos; 自定义一个事件类 123456789101112public class MessageEvent &#123; private String msg; public MessageEvent(String msg) &#123; this.msg = msg; &#125; public String getMsg() &#123; return msg; &#125;&#125; 在需要订阅事件的地方注册事件 1EventBus.getDefault.regist(this); 取消事件订阅 1EventBus.getDefault.unregist(this); 发送事件 1EventBus.getDefault().post(new MessageEvent(&quot;发送事件&quot;)); 处理事件 1234@Subscribe(threadMode = ThreadMode.MAIN_ORDERED)public void XXX(MessageEvent messageEvent) &#123; ...&#125; EventBus 应用 添加依赖 定义消息事件类 注册，取消订阅事件，事件处理事件 （都在MainActivity类中，就写一起了） 12345678910111213141516171819202122232425262728293031public class MainActivity extends AppCompatActivity &#123; private TextView tv; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); EventBus.getDefault().register(this); setContentView(R.layout.activity_main); tv = findViewById(R.id.tv); tv.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; startActivity(new Intent(MainActivity.this, SecActivity.class)); &#125; &#125;); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); EventBus.getDefault().unregister(this); &#125; @Subscribe(threadMode = ThreadMode.MAIN_ORDERED) public void cal(MessageEvent messageEvent)&#123; tv.setText(messageEvent.getMsg()); Toast.makeText(this,messageEvent.getMsg(),Toast.LENGTH_LONG).show(); &#125;&#125; 事件发布(为了简写：SecActivity 进入就发布) 1234567891011public class SecActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); EventBus.getDefault().post(new MessageEvent(&quot;SecActivity ~&quot;)); &#125;&#125; 看看效果：点击MainActivity的“helloworld” 进入 SecActivity，SecActivity onCreate（）中 post发布事件，MainActivity cal()执行，“helloworld”被改成“SecActivity ~”，同时Toast “SecActivity ~” 粘性事件除了上面讲的普通事件外，EventBus还支持发送黏性事件，就是在发送事件之后再订阅该事件也能收到该事件，跟黏性广播类似。为了验证粘性事件我们修改以前的代码： 订阅粘性事件在MainActivity中我们将注册事件移到到button的点击事件中：1234567bt_subscription.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //注册事件 EventBus.getDefault().register(MainActivity.this); &#125; &#125;); 订阅者处理粘性事件在MainActivity中新写一个方法用来处理粘性事件：1234@Subscribe(threadMode = ThreadMode.POSTING，sticky = true) public void ononMoonStickyEvent(MessageEvent messageEvent)&#123; tv_message.setText(messageEvent.getMessage()); &#125; 发送黏性事件在SecondActivity中发送粘性事件：1EventBus.getDefault().postSticky(new MessageEvent(&quot;粘性事件&quot;)); 混淆12345678910-keepattributes *Annotation*-keepclassmembers class * &#123; @org.greenrobot.eventbus.Subscribe &lt;methods&gt;;&#125;-keep enum org.greenrobot.eventbus.ThreadMode &#123; *; &#125; # Only required if you use AsyncExecutor-keepclassmembers class * extends org.greenrobot.eventbus.util.ThrowableFailureEvent &#123; &lt;init&gt;(java.lang.Throwable);&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android 第三方框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Retrofit-RxJava-OkHttp基础篇]]></title>
    <url>%2F2018%2F01%2F06%2FRetrofit-RxJava-OkHttp%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[介绍Retrofit: Retrofit是Square 公司开发的一款正对Android 网络请求的框架。底层基于OkHttp 实现，OkHttp 已经得到了google 官方的认可。Retrofit官网 OkHttp: 也是Square 开源的网络请求库 RxJava:RxJava 在 GitHub 主页上的自我介绍是 “a library for composing asynchronous and event-based programs using observable sequences for the Java VM”（一个在 Java VM 上使用可观测的序列来组成异步的、基于事件的程序的库）。这就是 RxJava ，概括得非常精准。总之就是让异步操作变得非常简单。 各自的职责：Retrofit 负责请求的数据和请求的结果，使用接口的方式呈现，OkHttp 负责请求的过程，RxJava 负责异步，各种线程之间的切换。 RxJava + Retrofit + okHttp 已成为当前Android 网络请求最流行的方式。 Retrofit 写一个网络请求以获取豆瓣 Top250 榜单为例，地址：https://api.douban.com/v2/movie/ 导包 12345678910//rxjava相关依赖compile &apos;io.reactivex:rxjava:1.2.1&apos;compile &apos;io.reactivex:rxandroid:1.2.1&apos;//retrofit相关依赖compile &apos;com.squareup.retrofit2:retrofit:2.1.0&apos;compile &apos;com.squareup.retrofit2:converter-gson:2.1.0&apos;compile &apos;com.squareup.retrofit2:adapter-rxjava:2.1.0&apos;//okhttp相关依赖compile &apos;com.squareup.okhttp3:okhttp:3.4.1&apos;compile &apos;com.squareup.okhttp3:logging-interceptor:3.4.1&apos; 创建一个Retrofit实例，并且完成相关的配置 1234Retrofit retrofit = new Retrofit.Builder() .baseUrl(BASE_URL) .addConverterFactory(GsonConverterFactory.create()) .build(); 说明：配置了接口的baseurl和一个converter，GsonConverterFactory是默认的Gson转换器，也支持其他转换器 创建接受结果的javabean1234567891011121314151617public class MovieSubject &#123; public String title; public String start; public String total; public String count; @Override public String toString() &#123; return &quot;MovieSubject&#123;&quot; + &quot;title=&apos;&quot; + title + &apos;\&apos;&apos; + &quot;, start=&apos;&quot; + start + &apos;\&apos;&apos; + &quot;, total=&apos;&quot; + total + &apos;\&apos;&apos; + &quot;, count=&apos;&quot; + count + &apos;\&apos;&apos; + &apos;&#125;&apos;; &#125;&#125; 创建一个接口123456public interface Service &#123; @GET(&quot;top250&quot;) Call&lt;MovieSubject&gt; getTop250(@Query(&quot;start&quot;) int start,@Query(&quot;count&quot;) int count);&#125; 说明：定义一个方法getTop250，使用get请求方式（@GET标签），标签后面是这个接口的尾址top250，完整的地址应该是baseUrl+尾址，参数使用@Query标签，如果参数多的话可以使用@QueryMap标签，接受一个Map 用Retrofit创建接口实例MoveService，并且调用接口中的方法进行网络请求12345678910111213141516//retrofit创建接口实例Service service = retrofit.create(Service.class);//调用getTop250方法Call&lt;MovieSubject&gt; top250 = service.getTop250(0, 5);//进行网络请求top250.enqueue(new Callback&lt;MovieSubject&gt;() &#123; @Override public void onResponse(Call&lt;MovieSubject&gt; call, Response&lt;MovieSubject&gt; response) &#123; Log.d(&quot;TAG&quot;,&quot;onResponse: &quot;+response.body().toString()); &#125; @Override public void onFailure(Call&lt;MovieSubject&gt; call, Throwable t) &#123; Log.d(&quot;TAG&quot;,&quot;onFailure&quot;); &#125; &#125;); POST请求上面的是GET请求，下面将它换成POST请求修改MoveService类1234567public interface Service &#123; @FormUrlEncoded //使用POST必须加上此标签 @POST(&quot;top250&quot;) Call&lt;MovieSubject&gt; getTop250(@Field(&quot;start&quot;) int start, @Field(&quot;count&quot;) int count);//@Query 改成了 @Field&#125; 配合RxJava使用 更改定义的接口，返回值Call-&gt;Observable 123456public interface Service &#123; @GET(&quot;top250&quot;) Observable&lt;MovieSubject&gt; getTop250(@Query(&quot;start&quot;) int start, @Query(&quot;count&quot;) int count);&#125; 创建Retrofit时添加代码 1addCallAdapterFactory(RxJavaCallAdapterFactory.create()) Subscriber订阅 123456789101112131415161718192021//retrofit创建接口实例Service service = retrofit.create(Service.class);service.getTop250(0,5) .subscribeOn(Schedulers.io()) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Subscriber&lt;MovieSubject&gt;() &#123; @Override public void onCompleted() &#123; Log.d(TAG,&quot;onCompleted&quot;); &#125; @Override public void onError(Throwable e) &#123; Log.d(TAG,&quot;onError: &quot;+e.toString()); &#125; @Override public void onNext(MovieSubject movieSubject) &#123; Log.d(TAG,&quot;onNext: &quot;+movieSubject.title); &#125; &#125;); 以上加入RxJava后的网络请求，返回的不再是Call，而是一个Observable，在Activity或Fragment中传入一个Subscriber建立订阅关系，就可以在onNext中处理结果了。RxJava的好处是处理线程间的切换 加入OkHttp配置通过OkHttpClient可以配置很多东西，比如超时，缓存，拦截器12345OkHttpClient.Builder builder = new OkHttpClient.Builder() .connectTimeout(60, TimeUnit.SECONDS);//拦截器builder.addInterceptor(new BasicParamsInterceptop()); 拦截器(应用拦截器添加公共参数) 新建类BasicParamsInterceptop implements Interceptor实现intercept方法 添加公共参数参数1234567891011121314151617181920212223242526272829303132333435363738394041@Overridepublic Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); String method = request.method(); Log.d(TAG,&quot;method :&quot;+method); //添加headder request = request.newBuilder() .addHeader(&quot;channel&quot;,&quot;android&quot;).build(); //GET请求 if (method.equals(&quot;GET&quot;))&#123; HttpUrl httpUrl = request.url().newBuilder() .addQueryParameter(&quot;version&quot;, &quot;version&quot;) .build(); request = request.newBuilder().url(httpUrl).build(); &#125; //POST请求 if(method.equals(&quot;POST&quot;))&#123; if (request.body() instanceof FormBody)&#123; FormBody.Builder builder = new FormBody.Builder(); //把原来的参数添加到新的构造器 FormBody request_formBody = (FormBody) request.body(); for (int i=0;i&lt;request_formBody.size();i++)&#123; builder.addEncoded(request_formBody.encodedName(i),request_formBody.encodedValue(i)); &#125; //添加新的参数 builder.add(&quot;type&quot;,&quot;app&quot;); request = request.newBuilder().post(builder.build()).build(); &#125; //打印参数 FormBody body = (FormBody) request.body(); for (int i=0;i&lt;body.size();i++)&#123; Log.d(TAG,&quot;new_body :&quot;+body.encodedName(i)); &#125; &#125; return chain.proceed(request);&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android 第三方框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RxJava + Retrofit 完成网络请求]]></title>
    <url>%2F2017%2F11%2F29%2FRxJava-Retrofit-%E5%AE%8C%E6%88%90%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[RxJava使用介绍一个在Java VM上使用可观测的序列来组成异步的,基于事件的程序的库.简单说它就是一个实现异步操作的库. 观察者模式 观察者: 监视被观察者的行为,当被观察组某个状态改变的时候会通知观察者,观察组执行对应的操作; 被观察者: 被监视的对象 订阅(或注册): 将观察者和被观察者建立联系 例子: 按钮点击事件(OnClickListener中的onClick()事件) 观察者: OnClickListener; 被观察者: Button; 订阅(或注册): setOnClickListener(); 对应RxJava中 观察者: Observer; 被观察者: Observable; 订阅(或注册): subscribe; 观察者Observer 即观察者,它决定事件触发的时候将有怎样的行为.RxJava 观察者的事件回调方法除了普通事件onNext()[相当于onClick()/onEvent()]之外,还定义了两个特殊的事件:onCompleted()和onError(). onCompleted() 事件队列完结.RxJava不仅把每个事件单独处理,还会把它们看成一个队列.RxJava规定,当不会再有新的onNext()发出时,需要触发onCompleted()方法作为标示. onError() 事件队列异常.在事件处理过程中出现异常时,onError()会被触发,同时队列自动终止,不允许再有事件发出. 在一个正确运行的事件序列中,onCompleted()和onError()有且只有一个,并且是事件序列中的最后一个.onCompleted()和onError()在队列中只会调用其中一个. 被观察者Observable 即被观察者,它决定什么时候触发事件以及触发怎样的事件.可以使用create(),just(T…),from(T[]),from(Iterable&lt;? extends T&gt;)来创建一个Observable,并为它定义事件触发规则. 订阅创建了Observable 和 Observer之后,再用subscribe()方法将他们连接起来 使用1.导包12compile &apos;io.reactivex:rxjava:1.0.14&apos;compile &apos;io.reactivex:rxandroid:1.0.1 2.创建一个观察者1234567891011121314Observer&lt;String&gt; observer = new Observer&lt;String&gt;() &#123; @Override public void onCompleted() &#123; Log.i(TAG, &quot;Completed&quot;); &#125; @Override public void onError(Throwable e) &#123; Log.i(TAG, &quot;Error&quot;); &#125; @Override public void onNext(String s) &#123; Log.i(TAG, s); &#125;&#125;; 3.创建被观察者12345678Observable observable1 = Observable.create(new Observable.OnSubscribe&lt;String&gt;() &#123; @Override public void call(Subscriber&lt;? super String&gt; subscriber) &#123; subscriber.onNext(&quot;Hello&quot;); subscriber.onNext(&quot;Wrold&quot;); subscriber.onCompleted(); &#125;&#125;); 4.订阅1observable1.subscribe(observer); 5.Observable其它几种创建方法 Observable.just() 1Observable observable = Observable.just(&quot;hi&quot;, &quot;le&quot;, &quot;ho&quot;); Observable.from() 12345List&lt;String&gt; list = new ArrayList&lt;String&gt;();list.add(&quot;Hellow&quot;);list.add(&quot;Wrold&quot;);String [] words = &#123;&quot;Hello&quot;, &quot;World&quot;&#125;;Observable observable3 = Observable.from(words|list); RxJava Action 使用回顾上节知识,介绍RxJava基本用法例:分别打印”hello” “world”123456789101112Observable.just(&quot;hello&quot;,&quot;world&quot;) .subscribe(new Subscriber&lt;String&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(String s) &#123; &#125; &#125;); 从上面可以看出我们只用了onNext(obj),还有两个重新的onError()和onCompleted()并没有用到,可是使用Action代替Subscriber. Action代替Subscriber用Action代替Subscriber1234567Observable.just(&quot;Hello&quot;, &quot;World&quot;) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, s); &#125; &#125;); RxJava 转换 -map -flatMapmap在使用map之前先了解一个接口: Func1, Func1和上文的Action1相似.Func1和Action1的区别在于,Func1包装的是有返回值的方法.例: 得到多个Studeng对象中的name,保存到nameList中123456789101112131415Observable.just(student1, student2, student2) //使用map进行转换，参数1：转换前的类型，参数2：转换后的类型 .map(new Func1&lt;Student, String&gt;() &#123; @Override public String call(Student i) &#123; String name = i.getName();//获取Student对象中的name return name;//返回name &#125; &#125;) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; nameList.add(s); &#125; &#125;); 可以看出Observable中原来的参数是Student对象,而最后我们需要的是name,这里使用了map来实现这一转换的过程.map也可以多次使用 flatMapflatMap是一个比教难理解的一个转换，在这里先假设一个需求，需要打印多个Student所学的课程。这跟之前获取Student的name又不同了，这里先确定一下关系，一个Student类中只有一个name，而一个Student却有多门课程（Course），Student我们可以理解成这样：12345678910111213141516/*** 学生类*/class Student &#123; private String name;//姓名 private List&lt;Course&gt; coursesList;//所修的课程 ...&#125;/*** 课程类*/class Course &#123; private String name;//课程名 private String id; ...&#125; 如何使用map实现打印所有学生所修的课程名12345678910111213Observable.from(students) .flatMap(new Func1&lt;Student, Observable&lt;Course&gt;&gt;() &#123; @Override public Observable&lt;Course&gt; call(Student student) &#123; return Observable.from(student.getCoursesList()); &#125; &#125;) .subscribe(new Action1&lt;Course&gt;() &#123; @Override public void call(Course course) &#123; Log.i(TAG, course.getName()); &#125;&#125;); RxJava 线程控制 - Scheduler由Observable发起事件,经过中间的处理后由Observer消费,之前的代码事件发起和消费都是在同一个线程中执行,也就是说之前我们使用的RxJava是同步的而观察者模式本身的目的是后台处理,将处理结果回调给前台上例中flatMap处理是在主线程中进行的,若flatMap中有耗时的操作,这样会导致主线程阻塞 Scheduler: 线程控制器,可以指定每一段代码在什么样的线程中执行例: 在新的线程中发起事件,在主线程中消费123456789Observable.just(&quot;Hello&quot;, &quot;Word&quot;) .subscribeOn(Schedulers.newThread())//指定 subscribe() 发生在新的线程 .observeOn(AndroidSchedulers.mainThread())// 指定 Subscriber 的回调发生在主线程 .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.i(TAG, s); &#125; &#125;); 上面用到了subscribeOn()发起,observeOn()消费subscribeOn()：指定subscribe() 所发生的线程，即 Observable.OnSubscribe 被激活时所处的线程。或者叫做事件产生的线程.observeOn()：指定Subscriber 所运行在的线程。或者叫做事件消费的线程。 多次切换线程1234567891011121314151617Observable.just(&quot;hello&quot;,&quot;hi&quot;) .subscribeOn(Schedulers.newThread()) .observeOn(Schedulers.io()) .filter(new Func1&lt;String, Boolean&gt;() &#123; @Override public Boolean call(String s) &#123; Log.d(TAG,&quot;filter thread: &quot;+Thread.currentThread().getId()); return true; &#125; &#125;) .observeOn(AndroidSchedulers.mainThread()) .subscribe(new Action1&lt;String&gt;() &#123; @Override public void call(String s) &#123; Log.d(TAG,&quot;Thread: &quot;+Thread.currentThread().getId()+&quot; &quot;+s); &#125; &#125;); 可以看出subserveOn()被调用两次,分别指定fliter处理和subscribe消费的线程如果去掉后面的.observeOn(AndroidSchedulers.mainThread()),那么 .subscribe将会在io线程中执行observeOn()可以多次使用，可以随意变换线程 Retrofit 使用Retrofit是Square公司开发的一个类型安全的Java和Android的REST客户端库(A type-safe HTTP client for Android and Java)RestAPI是一种软件设计风格,服务器作为资源存放地.客户端去请求GET POST PUT DELETE…资源.并且是无状态的,没有session的参与. Retrofit模型如下: 1.POJO或模型实体类: 从服务器获取的JSON数据将被填充到这种类的实例中2.接口: 我们需要创建一个接口来管理像GET POST…请求的URL,这是一个服务类.3.RestAdapter类: 这是一个REST客户端(RestClient)类,retrofit中默认用的是Gson来解析JSON数据,你也可以设置自己的JSON解析器. 原理在发起请求时,主要通过Call来封装每一次的请求;调用同步方法时,会使用应用线程来发送请求;调用异步方法时,会通过 OkHttp 的 Dispatcher 提供的线程来执行请求. Dispatcher: r内部实现了懒加载无边界限制的线程池方式，同时该线程池采用了SynchronousQueue这种阻塞队列。SynchronousQueue每个插入操作必须等待另一个线程的移除操作，同样任何一个移除操作都等待另一个线程的插入操作。显然这是一种快速传递元素的方式，也就是说在这种情况下元素总是以最快的方式从插入者（生产者）传递给移除者（消费者），这在多任务队列中是最快处理任务的方式。 Retrofit 使用准备工作:1.添加依赖12compile &apos;com.squareup.retrofit2:retrofit:2.0.2&apos;compile &apos;com.squareup.retrofit2:converter-gson:2.0.2&apos; 2.添加权限由于是网络请求,需要添加访问网络权限1&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot;/&gt; 步骤1.创建实体类12345678910111213141516171819public class User &#123; private String name; private String age; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getAge() &#123; return age; &#125; public void setAge(String age) &#123; this.age = ge &#125;&#125; 创建一个User类, name agePOJO的转换推荐使用GsonFormat 2.创建Retrofit对象12345Retrofit retrofit = new Retrofit.Builder() .addConverterFactory(GsonConverterFactory.create())//解析方法 //这里建议：- Base URL: 总是以/结尾；- @Url: 不要以/开头 .baseUrl(&quot;http://www.xxx.com/&quot;) .build(); 3.接口申明12345678910public interface Service &#123; /** * 根据id获取对应的用户数据 * 如果不需要转换成Json数据,可以用了ResponseBody; * @param id * @return call */ @GET(&quot;user/&#123;id&#125;&quot;) Call&lt;User&gt; getUser(@Path(&quot;id&quot;) String id);&#125; 4.创建访问API的请求12Service api = retrofit.create(Service .class);Call&lt;User&gt; call = api.getUser(&quot;123456&quot;); 5.调用5.1 同步调用1News news = call.execute(); 5.2 异步调用1234567891011call.enqueue(new Callback&lt;News&gt;()&#123; @Override public void onResponse(Response&lt;News&gt; response) &#123; //成功返回数据后在这里处理，使用response.body();获取得到的结果 News news = response.body(); &#125; @Override public voidonFailure(Throwable t) &#123; //请求失败在这里处理 &#125; &#125;); 6.取消请求1call.cancel(); RxJava + Retrofit 结合使用单独使用Retrofit1.service接口1234567interface MyService &#123; @GET(&quot;user/login&quot; ) Call&lt;UserInfo&gt; login( @Query(&quot;username&quot;) String username, @Query(&quot;password&quot;) String password );&#125; 2.获取Call执行网络请求123456789101112131415161718Retrofit retrofit = new Retrofit.Builder() .addConverterFactory(GsonConverterFactory.create()) .baseUrl(BASE_URL) .build();MyService service = retrofit.create(MyService.class);Call&lt;UserInfo&gt; call = service.login(&quot;1111&quot;, &quot;ssss&quot;);call.enqueue(new Callback&lt;UserInfo&gt;() &#123; @Override public void onResponse(Call&lt;UserInfo&gt; call, Response&lt;UserInfo&gt; response) &#123; //请求成功操作 &#125; @Override public void onFailure(Call&lt;UserInfo&gt; call, Throwable t) &#123; //请求失败操作 &#125;&#125;); RxJava + Retrofit 完成网络请求1.添加依赖 前四个分别是RxJava、RxAndroid、Retrofit以及Gson的库，最后那个才是新加入的，RxJava + Retrofit的使用需要用到最后那个包。12345compile &apos;io.reactivex:rxjava:x.y.z&apos;compile &apos;io.reactivex:rxandroid:1.0.1&apos;compile &apos;com.squareup.retrofit2:retrofit:2.0.2&apos;compile &apos;com.squareup.retrofit2:converter-gson:2.0.2&apos;compile &apos;com.squareup.retrofit2:adapter-rxjava:2.0.2&apos; 注意: 最后三个包的版本号必须一样2.修改service(Call改为Observable)1234567interface MyService &#123; @GET(&quot;user/login&quot; ) Observable&lt;UserInfo&gt; login( @Query(&quot;username&quot;) String username, @Query(&quot;password&quot;) String password );&#125; 3.网络请求12345678910111213141516171819202122232425262728Retrofit retrofit = new Retrofit.Builder() .addConverterFactory(GsonConverterFactory.create()) .baseUrl(BASE_URL) .build();MyService service = retrofit.create(MyService.class);service.loging(username,password) .subscribeOn(Schedulers.newThread())//请求在新的线程中执行 .observeOn(Schedulers.io()) //请求完成后在io线程中执行 .doOnNext(new Action1&lt;UserInfo&gt;() &#123; @Override public void call(UserInfo userInfo) &#123; saveUserInfo(userInfo);//保存用户信息到本地 &#125; &#125;) .observeOn(AndroidSchedulers.mainThread())//最后在主线程中执行 .subscribe(new Subscriber&lt;UserInfo&gt;() &#123; @Override public void onCompleted() &#123; &#125; @Override public void onError(Throwable e) &#123; &#125; @Override public void onNext(UserInfo userInfo) &#123; &#125; &#125;); Retrofit把请求封装进Observable,在请求结束后调用onNext() onError() 或 onCompleted().在调用service的login方法后得到Observable对象, .subscribeOn(Scheduler.newThread())在新的线程中执行网络请求,请求成功后切换到io线程执行保存用户信息动作,最后再切换到主线程执行请求失败,成功动作.整体逻辑都在一条链中,即使有变更也好添加修改.逻辑清晰. 引用【Android】RxJava + Retrofit完成网络请求]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android 第三方框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView]]></title>
    <url>%2F2017%2F11%2F09%2FRecyclerView%2F</url>
    <content type="text"><![CDATA[前言谷歌在support v7中,加入了新的控件-RecyclerView用来代替ListView GridView,结合了ListView GridView的特点,并实现了瀑布流效果. 导包需要v7 包支持1implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; 几个重要的类 RecyclerView.Adapter:抽象类，为RecyclerView提供数据，一般根据不同的业务需求来编写具体的实现类。 RecyclerView.LayoutManager:抽象类，主要用于测量RecyclerView的子Item，以及根据不同的布局方式来实现Item的布局效果，v 7包自带的实现类有：LinearLayoutManager、StaggeredGridLayoutManager、GridLayoutManager… RecyclerView.ItemDecoration:抽象类，这个主要用于不同的Item之间添加分割线（可选）。官方没有实现类，所以如果要添加分割线，我们需要手动实现这个抽象类 RecyclerView.ItemAnimator:抽象类，这个主要用于当一个item添加或者删除的时候出现的动画效果，官方提供一个默认的实现类。如果想要使我们的RecyclerView在添加、删除数据的时候有炫酷的动画，可以实现这个抽象类 xml布局123456789101112131415161718192021222324252627&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.v7.widget.Toolbar android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:titleTextColor=&quot;@color/white&quot; app:title=&quot;RecyclerView&quot;/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v7.widget.RecyclerView android:id=&quot;@+id/recyclerview&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;/android.support.v7.widget.RecyclerView&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 这里使用了4个控件, CoordinatorLayout, AppBarLayout, Toolbar和本文的RecyclerView item_recyclerview.xml123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_item&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;70dp&quot; android:background=&quot;#ccc&quot; /&gt;&lt;/RelativeLayout&gt; item布局只有一个TextView, 背景颜色灰色 java代码(初试)1234RecyclerView recyclerview = findViewById(R.id.recyclerview);recyclerview.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false));MyAdapter myAdapter = new MyAdapter(data);recyclerview.setAdapter(myAdapter); 代码解析:recyclerview.setLayoutManager:设置布局管理器 LinearLayoutManager 以垂直或水平列表方式展示 GridLayoutManager 以网格方式展示 StaggeredGridLayoutManager 以瀑布流方式展示 recyclerview.setAdapter:设置适配器,适配器代码如下12345678910111213141516171819202122232425262728293031323334353637383940414243private class MyAdapter extends RecyclerView.Adapter&lt;MyAdapter.ViewHolder&gt;&#123; private ArrayList&lt;String&gt; mData; public MyAdapter(ArrayList&lt;String&gt; data) &#123; this.mData = data; &#125; public void updateData(ArrayList&lt;String&gt; data) &#123;//用户数据更新 this.mData = data; notifyDataSetChanged(); &#125; @Override public MyAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; //实例化展示的View, View inflate = View.inflate(RecyclerViewActivity.this, R.layout.item_recyclerview, null); //实例化ViewHolder ViewHolder viewHolder = new ViewHolder(inflate); return viewHolder; &#125; @Override public void onBindViewHolder(ViewHolder holder, int position) &#123; //holder就是onCreateViewHolder返回, 绑定数据 holder.textView.setText(mData.get(position)); &#125; @Override public int getItemCount() &#123; return mData.size(); &#125; public class ViewHolder extends RecyclerView.ViewHolder&#123; TextView textView; public ViewHolder(View itemView) &#123; super(itemView); textView = itemView.findViewById(R.id.tv_item); &#125; &#125; &#125; 效果图:效果和ListView一样,但是item直接没有分割线,xml文件中也不能设置分割线,可以通过mRecyclerView.addItemDecoration()来设置我们定义好的间隔样式. 添加分割线LinearLayoutManager 分割线12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public class DividerItemDecoration extends RecyclerView.ItemDecoration&#123; private static final int[] ATTRS = new int[]&#123; android.R.attr.listDivider &#125;; public static final int HORIZONTAL_LIST = LinearLayoutManager.HORIZONTAL; public static final int VERTICAL_LIST = LinearLayoutManager.VERTICAL; private Drawable mDivider; private int mOrientation; public DividerItemDecoration(Context context, int orientation) &#123; final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); setOrientation(orientation); &#125; public void setOrientation(int orientation) &#123; if (orientation != HORIZONTAL_LIST &amp;&amp; orientation != VERTICAL_LIST) &#123; throw new IllegalArgumentException(&quot;invalid orientation&quot;); &#125; mOrientation = orientation; &#125; @Override public void onDraw(Canvas c, RecyclerView parent) &#123; if (mOrientation == VERTICAL_LIST) &#123; drawVertical(c, parent); &#125; else &#123; drawHorizontal(c, parent); &#125; &#125; public void drawVertical(Canvas c, RecyclerView parent) &#123; final int left = parent.getPaddingLeft(); final int right = parent.getWidth() - parent.getPaddingRight(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); android.support.v7.widget.RecyclerView v = new android.support.v7.widget.RecyclerView(parent.getContext()); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int top = child.getBottom() + params.bottomMargin; final int bottom = top + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; public void drawHorizontal(Canvas c, RecyclerView parent) &#123; final int top = parent.getPaddingTop(); final int bottom = parent.getHeight() - parent.getPaddingBottom(); final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int left = child.getRight() + params.rightMargin; final int right = left + mDivider.getIntrinsicHeight(); mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; @Override public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) &#123; if (mOrientation == VERTICAL_LIST) &#123; outRect.set(0, 0, 0, mDivider.getIntrinsicHeight()); &#125; else &#123; outRect.set(0, 0, mDivider.getIntrinsicWidth(), 0); &#125; &#125;&#125; 12recyclerview.setLayoutManager(new LinearLayoutManager(this,LinearLayoutManager.VERTICAL,false));recyclerview.addItemDecoration(new com.newyulong.materialdesignstu.DividerItemDecoration.DividerItemDecoration(this, com.newyulong.materialdesignstu.DividerItemDecoration.DividerItemDecoration.VERTICAL_LIST)); 效果图: GridLayoutManager分割线123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175public class DividerGridItemDecoration extends RecyclerView.ItemDecoration &#123; private static final int[] ATTRS = new int[] &#123; android.R.attr.listDivider &#125;; private Drawable mDivider; private int divider_height = 2; public DividerGridItemDecoration(Context context) &#123; final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); a.recycle(); &#125; public DividerGridItemDecoration(Context context,int px_divider_height) &#123; final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); mDivider.setColorFilter(Color.WHITE,PorterDuff.Mode.SRC); divider_height = px_divider_height; a.recycle(); &#125; public DividerGridItemDecoration(Context context,int px_divider_height,int divider_color) &#123; final TypedArray a = context.obtainStyledAttributes(ATTRS); mDivider = a.getDrawable(0); mDivider.setColorFilter(divider_color,PorterDuff.Mode.SRC); divider_height = px_divider_height; a.recycle(); &#125; @Override public void onDraw(Canvas c, RecyclerView parent, RecyclerView.State state) &#123; drawHorizontal(c, parent); drawVertical(c, parent); &#125; private int getSpanCount(RecyclerView parent) &#123; // 列数 int spanCount = -1; RecyclerView.LayoutManager layoutManager = parent.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) &#123; spanCount = ((GridLayoutManager) layoutManager).getSpanCount(); &#125; else if (layoutManager instanceof StaggeredGridLayoutManager) &#123; spanCount = ((StaggeredGridLayoutManager) layoutManager) .getSpanCount(); &#125; return spanCount; &#125; public void drawHorizontal(Canvas c, RecyclerView parent) &#123; int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int left = child.getLeft() - params.leftMargin; final int right = child.getRight() + params.rightMargin + divider_height; final int top = child.getBottom() + params.bottomMargin; final int bottom = top + divider_height; mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; public void drawVertical(Canvas c, RecyclerView parent) &#123; final int childCount = parent.getChildCount(); for (int i = 0; i &lt; childCount; i++) &#123; final View child = parent.getChildAt(i); final RecyclerView.LayoutParams params = (RecyclerView.LayoutParams) child .getLayoutParams(); final int top = child.getTop() - params.topMargin; final int bottom = child.getBottom() + params.bottomMargin; final int left = child.getRight() + params.rightMargin; final int right = left + divider_height; mDivider.setBounds(left, top, right, bottom); mDivider.draw(c); &#125; &#125; private boolean isLastColum(RecyclerView parent, int pos, int spanCount, int childCount) &#123; RecyclerView.LayoutManager layoutManager = parent.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) &#123; if ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边 &#123; return true; &#125; &#125; else if (layoutManager instanceof StaggeredGridLayoutManager) &#123; int orientation = ((StaggeredGridLayoutManager) layoutManager) .getOrientation(); if (orientation == StaggeredGridLayoutManager.VERTICAL) &#123; if ((pos + 1) % spanCount == 0)// 如果是最后一列，则不需要绘制右边 &#123; return true; &#125; &#125; else &#123; childCount = childCount - childCount % spanCount; if (pos &gt;= childCount)// 如果是最后一列，则不需要绘制右边 return true; &#125; &#125; return false; &#125; private boolean isLastRaw(RecyclerView parent, int pos, int spanCount, int childCount) &#123; RecyclerView.LayoutManager layoutManager = parent.getLayoutManager(); if (layoutManager instanceof GridLayoutManager) &#123; childCount = childCount - childCount % spanCount; if (pos &gt;= childCount)// 如果是最后一行，则不需要绘制底部 return true; &#125; else if (layoutManager instanceof StaggeredGridLayoutManager) &#123; int orientation = ((StaggeredGridLayoutManager) layoutManager) .getOrientation(); // StaggeredGridLayoutManager 且纵向滚动 if (orientation == StaggeredGridLayoutManager.VERTICAL) &#123; childCount = childCount - childCount % spanCount; // 如果是最后一行，则不需要绘制底部 if (pos &gt;= childCount) return true; &#125; else // StaggeredGridLayoutManager 且横向滚动 &#123; // 如果是最后一行，则不需要绘制底部 if ((pos + 1) % spanCount == 0) &#123; return true; &#125; &#125; &#125; return false; &#125; @Override public void getItemOffsets(Rect outRect, int itemPosition, RecyclerView parent) &#123; int spanCount = getSpanCount(parent); int childCount = parent.getAdapter().getItemCount(); if (isLastRaw(parent, itemPosition, spanCount, childCount))// 如果是最后一行，则不需要绘制底部 &#123; outRect.set(0, 0, divider_height, 0); &#125; else if (isLastColum(parent, itemPosition, spanCount, childCount))// 如果是最后一列，则不需要绘制右边 &#123; outRect.set(0, 0, 0, divider_height); &#125; else &#123; outRect.set(0, 0, divider_height,divider_height); &#125; &#125;&#125; 123recyclerview.addItemDecoration(new com.newyulong.materialdesignstu.DividerItemDecoration.DividerItemDecoration(this, com.newyulong.materialdesignstu.DividerItemDecoration.DividerItemDecoration.VERTICAL_LIST));//recyclerview.setLayoutManager(new GridLayoutManager(this,4,LinearLayoutManager.HORIZONTAL,false));//横向GridViewrecyclerview.addItemDecoration(new DividerGridItemDecoration(this)); 效果图: 瀑布流StaggeredGridLayoutManager:瀑布流布局管理器1recyclerview.setLayoutManager(new StaggeredGridLayoutManager(3,StaggeredGridLayoutManager.VERTICAL)); 效果图:居然和GridLayoutManager的效果一样!修改第二项item的高度为80,其他的为160 item点击事件在MyAdapter中定义如下接口,模拟ListView的OnItemClickListener：123public static interface OnItemClickListener &#123; void onItemClick(View view , int position); &#125; 在onCreateViewHolder()中为每个item添加点击事件12345678@Override public ViewHolder onCreateViewHolder(ViewGroup viewGroup, int viewType) &#123; View view = LayoutInflater.from(viewGroup.getContext()).inflate(R.layout.item, viewGroup, false); ViewHolder vh = new ViewHolder(view); //将创建的View注册点击事件 view.setOnClickListener(this); return vh; &#125; 将点击事件转移给外面的调用者：1234567@Override public void onClick(View v) &#123; if (mOnItemClickListener != null) &#123; //注意这里使用getTag方法获取position mOnItemClickListener.onItemClick(v,(int)v.getTag()); &#125; &#125; 注意上面调用接口的onItemClick()中的v.getTag()方法，这需要在onBindViewHolder()方法中设置和item的position123456@Override public void onBindViewHolder(ViewHolder viewHolder, int position) &#123; viewHolder.mTextView.setText(datas[position]); //将position保存在itemView的Tag中，以便点击时进行获取 viewHolder.itemView.setTag(position); &#125; 最后暴露给外面的调用者，定义一个设置Listener的方法（）：1234private OnItemClickListener mOnItemClickListener = null;public void setOnItemClickListener(OnItemClickListener listener) &#123; this.mOnItemClickListener = listener; &#125; 总结本文讲的是RecycView布局,列表形式,网格形式,瀑布流形式.使用RecycView需要设置布局管理器(LinearLayoutManager,GridLayoutManager,StaggeredGridLayoutManager)同样需要适配器(继承RecyclerView.Adapter), 需要重写onCreateViewHolder方法(实例化ViewHolder), onBindViewHolder方法(得到ViewHolder,绑定数据), 以及getItemCount方法,还需要定义ViewHolder类继承RecyclerView.ViewHolder类设置分割线设置动画(删除,增加item时的动画)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CollapsingToolbarLayout]]></title>
    <url>%2F2017%2F11%2F08%2FCollapsingToolbarLayout%2F</url>
    <content type="text"><![CDATA[简介CollapsingToolbarLayoutCollapsingToolbarLayout作用是提供一个可以折叠的Toolbar,给它设置layout_scrollFlags,就可以控制其内的控件(如:ImageView,Toolbar)在响应layout_behavior事件时做出相应的scrollFlags滚动事件. xml布局文件12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.design.widget.CollapsingToolbarLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;300dp&quot; app:contentScrim=&quot;@color/colorPrimary&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot; app:title=&quot;Toolbar&quot;&gt; &lt;ImageView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:scaleType=&quot;centerCrop&quot; android:src=&quot;@mipmap/coll&quot; app:layout_collapseMode=&quot;parallax&quot; app:layout_collapseParallaxMultiplier=&quot;0.5&quot; /&gt; &lt;android.support.v7.widget.Toolbar android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;?attr/actionBarSize&quot; app:layout_collapseMode=&quot;pin&quot; app:navigationIcon=&quot;@mipmap/back_black_arra&quot; /&gt; &lt;/android.support.design.widget.CollapsingToolbarLayout&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;&gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;@string/txt_appbar&quot; /&gt; &lt;/android.support.v4.widget.NestedScrollView&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; CollapsingToolbarLayout包含一个ImageView和一个Toolbar,把这个CollapsingToolbarLayout放到AppBarLayout中作为一个整体。 在CollapsingToolbarLayout中: 我们必须设置layout_scrollFlags ImageView中: layout_collapseMode(折叠模式): pin: 当CollapsingToolbarLayout完全收缩后,Toolbar还可以保留在屏幕上. parallax: 在内容滚动时，CollapsingToolbarLayout中的View（比如ImageView)也可以同时滚动，实现视差滚动效果，通常和layout_collapseParallaxMultiplier(设置视差因子)搭配使用 layout_collapseParallaxMultiplier: 设置视差滚动因子，值为：0~1 Toolbar中: layout_collapseMode(折叠模式)：为pin(Toolbar保留在屏幕上) 上例分析: 当向上滚动时,ImageView会有视觉差的向上滚出屏幕,最后Toolbar会固定在最顶端效果图: 样式修改修改Toolbar title颜色12ctl.setExpandedTitleColor(getResources().getColor(R.color.white));ctl.setCollapsedTitleTextColor(getResources().getColor(R.color.white)); 修改折叠后Toolbar背景颜色 (app:contentScrim)上例xml文件中已经将Toolbar背景颜色修改过,1234567&lt;android.support.design.widget.CollapsingToolbarLayout android:id=&quot;@+id/ctl&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;300dp&quot; app:contentScrim=&quot;@color/colorPrimary&quot; app:layout_scrollFlags=&quot;scroll|exitUntilCollapsed&quot; app:title=&quot;Toolbar&quot;&gt; 不然会显示ImageView内容,去掉看看 总结CollapsingToolbarLayout是Toolbar的扩充,提供折叠功能.使用时,用它包含Toolbar和其他内容(如ImageView)达到炫酷的效果.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AppBarLayout]]></title>
    <url>%2F2017%2F11%2F08%2FAppBarLayout%2F</url>
    <content type="text"><![CDATA[官方文档介绍AppBarLayout是一个垂直的LinearLayout，实现了Material Design中app bar的scrolling gestures特性。AppBarLayout的子View应该声明想要具有的“滚动行为”，这可以通过layout_scrollFlags属性或是setScrollFlags()方法来指定。AppBarLayout只有作为CoordinatorLayout的直接子View时才能正常工作，为了让AppBarLayout能够知道何时滚动其子View，我们还应该在CoordinatorLayout布局中提供一个可滚动View，我们称之为scrolling view。scrolling view和AppBarLayout之间的关联，通过将scrolling view的Behavior设为AppBarLayout.ScrollingViewBehavior来建立。根据上文我们知道,AppBarLayout主要功能是当位于同一父容器中的可滚动View发生滚动式,APPBarLayout会根据scolling view声明的滚动行为来对其子View进行相应的滚动.先来看张图:AppBarLayout包含Toolbar和一个TextView(没有设置scrollFlags)当向上滚动式,ToolBar会消失;向下滚动时,ToolBar会出现.AppBarLayout就是这么神奇 xml布局文件上面例子的xml布局文件:123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;android.support.design.widget.AppBarLayout android:id=&quot;@+id/abl&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;android.support.v7.widget.Toolbar android:layout_width=&quot;match_parent&quot; app:title=&quot;Toolbar&quot; app:layout_scrollFlags=&quot;scroll&quot; android:layout_height=&quot;?attr/actionBarSize&quot;&gt; &lt;/android.support.v7.widget.Toolbar&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:padding=&quot;15dp&quot; android:text=&quot;toolbar 下方的textview&quot;/&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;android.support.v4.widget.NestedScrollView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot; &gt; &lt;TextView android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:text=&quot;@string/txt_appbar&quot; android:lineSpacingMultiplier=&quot;1.5&quot;/&gt; &lt;/android.support.v4.widget.NestedScrollView&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 布局文件中,NestedScrollView是scrolling view,scrolling view需要支持嵌套滚动. 上面的Toolbar的layout_scrollFlags属性被设置为了”scroll”,Toolbar就会随着scrolling view的滚动而滚动,下面解释下scrollFlags: scroll 设置成这个值就好比Toolbar和scrolling view是一体的. exitUntilCollapsed 当Toolbar向上滚出屏幕时,会被折叠直到达到最小高度停止折叠 下图为了演示,将Toolbar的高度设置成200dp,注释掉Toolbar下方的TextView enterAlways 只要向下滚动时,先滚动Toolbar,完全展开后才会去滚动scrolling view enterAlwaysCollapsed 在enterAlways基础上加了折叠效果.当我们开始向下滚动scrolling view是,Toolbar会跟着滚动知道达到其”折叠高度”(即最小高度).然后当scrolling view滚动到完全显示后,再向下滚动scrolling view,Toolbar会接着滚动到完全显示出来 注意,要达到上图效果,需要把layout_scrollFlags指定为”scroll|enterAlways|enterAlwaysCollapsed”. snap 在一次滚动结束时，Toolbar很可能只处于“部分显示”的状态，加上这个标记能够达到“要么完全隐藏，要么完全显示”的效果。 总结 AppBarLayout是一个垂直的LinearLayout AppBarLayout需要和CoordinatorLayout一起使用,并作为它的直接子View 为了实现滚动还应在Coordinator布局中提供一个可滚动View(scrolling view),scrolling view还需设置app:layout_behavior=”@string/appbar_scrolling_view_behavior”建立联系 设置AppBarLayout子View的scrollFlag属性,控制其可以根据scrolling view的滚到而滚动]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CoordinatorLayout]]></title>
    <url>%2F2017%2F11%2F08%2FCoordinatorLayout%2F</url>
    <content type="text"><![CDATA[CoordinatorLayout并不局限于与AppbarLayout,CollapsingToolbarLayout,Toolbar配合使用,它的功能强大着呢.CoordinatorLayout:behaivor协调view,它是帮助协调各个子View的布局.其中Behavior就是一个应用于View的观察者模式,一个View跟随着另一个View的变化而变化,或者说一个View监听另一个View.在Behavior中,被观察View也就是事件源被称为denpendcy,而观察View,则被称为clild. clild跟随denpendcy CoordinatorLayout使用xml1234567891011121314151617181920&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;Button android:id=&quot;@+id/btn&quot; android:layout_width=&quot;100dp&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;btn&quot; /&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;100dp&quot; android:text=&quot;跟随btn&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; Activity123456789101112131415161718192021public class CoordinatorLayoutActivity extends AppCompatActivity &#123; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_coordinatorlayout); Button btn = findViewById(R.id.btn); btn.setOnTouchListener(new View.OnTouchListener() &#123; @Override public boolean onTouch(View v, MotionEvent event) &#123; switch (event.getAction())&#123; case MotionEvent.ACTION_MOVE: v.setX(event.getRawX()-v.getWidth()/2); v.setY(event.getRawY()-v.getHeight()/2); break; &#125; return false; &#125; &#125;); &#125;&#125; 按钮可以跟随手指移动 自定义类集成Behavior类创建一MyBehavior类,集成Behavior123456789101112131415161718public class MyBehavior extends CoordinatorLayout.Behavior&lt;TextView&gt; &#123; public MyBehavior(Context context, AttributeSet attrs) &#123;//必不可少 super(context, attrs); &#125; @Override public boolean layoutDependsOn(CoordinatorLayout parent, TextView child, View dependency) &#123; return dependency instanceof Button; &#125; @Override public boolean onDependentViewChanged(CoordinatorLayout parent, TextView child, View dependency) &#123; child.setX(dependency.getX());//此处的denpendency就是btn1 child.setY(dependency.getY()+200); return true; &#125;&#125; 注意:layoutDependsOn() 代表寻找被观察View,本例是ButtononDependentViewChanged() 被观察View变化的时候回调用的方法,本例是TextView.其中dependency就是Button,于是我们让TextView跟随Button的移动而移动必须重写带双参的构造器，因为从xml反射需要调用。然后，在xml中，给TextView设置我们的Behavior。123456&lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginTop=&quot;100dp&quot; android:text=&quot;跟随btn&quot; app:layout_behavior=&quot;.behavior.MyBehavior&quot; /&gt; 效果图: 总结本文讲解CoordinatorLayout的使用,一个Child(TextView) 跟随 dependency移动,定义一个继承Behavior的类,Child(TextView)增加app:layout_behavior属性指向这个类,那么就可实现跟随动作]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TabLayout]]></title>
    <url>%2F2017%2F11%2F07%2FTabLayout%2F</url>
    <content type="text"><![CDATA[TabLayout是Android Support Design Library库中的一个控件,提供了一个水平的布局用来展示Tabs。 导包使用Snackbar要导入com.android.support:design库。1compile &apos;com.android.support:design:26.1.0&apos; 一般使用 xml文件 12345678&lt;android.support.design.widget.TabLayout android:id=&quot;@+id/tabLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:background=&quot;#eee&quot; app:tabSelectedTextColor=&quot;#666&quot; app:tabTextColor=&quot;#ccc&quot;&gt;&lt;/android.support.design.widget.TabLayout&gt; java代码 1234TabLayout tabLayout = findViewById(R.id.tabLayout);tabLayout.addTab(tabLayout.newTab().setText(&quot;tab1&quot;));tabLayout.addTab(tabLayout.newTab().setText(&quot;tab2&quot;));tabLayout.addTab(tabLayout.newTab().setText(&quot;tab3&quot;)); 效果图 样式修改 设置未选择时字体颜色 1app:tabTextColor=&quot;#0f0&quot; 设置选中时的字体颜色 1app:tabSelectedTextColor=&quot;@color/colorAccent&quot; 设置指示器颜色 1app:tabIndicatorColor=&quot;#f00&quot; 设置Tab背景颜色 1app:tabBackground=&quot;@color/blue&quot; 看看效果: 设置TabItem字体大小 1app:tabTextAppearance=&quot;@android:style/TextAppearance.Large&quot; 设置指示器下标高度 1app:tabIndicatorHeight=&quot;5dp&quot; Tab模式 1app:tabMode=&quot;scrollable&quot; //默认为fixed 添加图标 1tabLayout.addTab(tabLayout.newTab().setText(&quot;icon&quot;).setIcon(R.mipmap.ic_launcher)); 多添加几个tag,看看效果: Tab宽度限制设置最小宽度:app:tabMinWidth=”100dp”可以看出每个Tab的宽度变宽了 TabLayout的监听事件1234567891011121314tabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; public void onTabSelected(TabLayout.Tab tab) &#123; //tab被选中 Log.d(TAG,&quot;onTabSelected: &quot;+tab.getPosition()); &#125; public void onTabUnselected(TabLayout.Tab tab) &#123; //tab取消选中 Log.d(TAG,&quot;onTabUnselected: &quot;+tab.getPosition()); &#125; public void onTabReselected(TabLayout.Tab tab) &#123; //tab再次被选中 Log.d(TAG,&quot;onTabReselected: &quot;+tab.getPosition()); &#125;&#125;); 切换Tab,看看日志:0 -&gt; 1: 0unSelected 1selected1 -&gt; 3: 1unSelected 3selected3 -&gt; 0: 3unSelected 0selected TabLayout与ViewPager联动 配置viewpage的adapter,实现getPageTitle(position)方法 使用setupWithViewPager(viewpager)关联代码如下:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869public class TabLayoutActivity extends AppCompatActivity &#123; private final static String TAG = &quot;TabLayoutActivity&quot;; private String[] mTitleArray = &#123;&quot;item1&quot;, &quot;xitem2&quot;, &quot;xxxitem3&quot;, &quot;xxxxitem4&quot;,&quot;xxxxxitem5&quot;&#125;; @Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_tablayout); TabLayout tabLayout = findViewById(R.id.tabLayout); ViewPager vp = findViewById(R.id.vp); vp.setAdapter(new MyAdapter());// 去掉addTab(),从viewpage 的 getPageTitle()中获取// tabLayout.addTab(tabLayout.newTab().setText(&quot;icon&quot;).setIcon(R.mipmap.ic_launcher));// tabLayout.addTab(tabLayout.newTab().setText(&quot;tab1&quot;));// tabLayout.addTab(tabLayout.newTab().setText(&quot;tab2&quot;));// tabLayout.addTab(tabLayout.newTab().setText(&quot;tab3&quot;));// tabLayout.addTab(tabLayout.newTab().setText(&quot;tab4&quot;));// tabLayout.addTab(tabLayout.newTab().setText(&quot;tab5&quot;));// tabLayout.addTab(tabLayout.newTab().setText(&quot;tab6&quot;)); tabLayout.setupWithViewPager(vp);//关联viewpager tabLayout.addOnTabSelectedListener(new TabLayout.OnTabSelectedListener() &#123; public void onTabSelected(TabLayout.Tab tab) &#123; //tab被选中 Log.d(TAG,&quot;onTabSelected: &quot;+tab.getPosition()); &#125; public void onTabUnselected(TabLayout.Tab tab) &#123; //tab取消选中 Log.d(TAG,&quot;onTabUnselected: &quot;+tab.getPosition()); &#125; public void onTabReselected(TabLayout.Tab tab) &#123; //tab再次被选中 Log.d(TAG,&quot;onTabReselected: &quot;+tab.getPosition()); &#125; &#125;); &#125; private class MyAdapter extends PagerAdapter &#123; public int getCount() &#123; return mTitleArray.length; &#125; public boolean isViewFromObject(View view, Object object) &#123; return view == object; &#125; @Override public Object instantiateItem(ViewGroup container, int position) &#123; TextView tv = new TextView(TabLayoutActivity.this); tv.setText(mTitleArray[position]); tv.setGravity(Gravity.CENTER); container.addView(tv, ViewPager.LayoutParams.MATCH_PARENT, ViewPager.LayoutParams.WRAP_CONTENT); return tv; &#125; @Override public void destroyItem(ViewGroup container, int position, Object object) &#123; container.removeView((View) object); &#125; @Override public CharSequence getPageTitle(int position) &#123; return mTitleArray[position];//title给TabLayout使用 &#125; &#125;&#125; 效果图: 扩展(设置下划线宽度和文字一样长)12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public void reflex(final TabLayout tabLayout, final int margin, final int padding) &#123; //了解源码得知 线的宽度是根据 tabView的宽度来设置的 tabLayout.post(new Runnable() &#123; @Override public void run() &#123; try &#123; //拿到tabLayout的mTabStrip属性 LinearLayout mTabStrip = (LinearLayout) tabLayout.getChildAt(0); //计算总长度 float sumWith = 0; for (int i = 0; i &lt; mTabStrip.getChildCount(); i++) &#123; View tabView = mTabStrip.getChildAt(i); //拿到tabView的mTextView属性 tab的字数不固定一定用反射取mTextView Field mTextViewField = tabView.getClass().getDeclaredField(&quot;mTextView&quot;); mTextViewField.setAccessible(true); TextView mTextView = (TextView) mTextViewField.get(tabView); tabView.setPadding(0, 0, 0, 0); //因为我想要的效果是 字多宽线就多宽，所以测量mTextView的宽度 int width = 0; width = mTextView.getWidth(); if (width == 0) &#123; mTextView.measure(0, 0); width = mTextView.getMeasuredWidth(); &#125; //设置tab左右间距为10dp 注意这里不能使用Padding 因为源码中线的宽度是根据 tabView的宽度来设置的 LinearLayout.LayoutParams params = (LinearLayout.LayoutParams) tabView.getLayoutParams(); params.width = width + 2 * padding; params.leftMargin = margin; params.rightMargin = margin; tabView.setLayoutParams(params); tabView.invalidate(); sumWith += 2 * margin + 2 * padding + width; &#125; int sc_with = getWindowManager().getDefaultDisplay().getWidth(); if (sumWith &lt;= sc_with) &#123;//总长度小于屏幕宽度时MODE_FIXED,否则MODE_SCROLLABLE tabLayout.setTabMode(TabLayout.MODE_FIXED); &#125; else &#123; tabLayout.setTabMode(TabLayout.MODE_SCROLLABLE); &#125; &#125; catch (NoSuchFieldException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; &#125;);&#125; 下划线和文字一样长,并且可以设置所tabitem的数量动态调整TabMode(MODE_FIXED|MODE_SCROLLABLE),可以设置margin和padding. 总结本文讲解了TabLayout的常规使用:背景颜色,选中未选中颜色,指示器高度颜色…属性介绍TabLayout大多和ViewPager配合使用:使用setupWithViewPager(viewpager)关联ViewPager,适配器还要实现getPagerTitle(position)方法返回title供TabLayout tabItem使用]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FloatingActionButton]]></title>
    <url>%2F2017%2F11%2F07%2FFloatingActionButton%2F</url>
    <content type="text"><![CDATA[FloatingActionButton是Android Support Design Library库中的一个控件,类似一个圆形图片按钮 导包使用FloatingActionButton要导入com.android.support:design库。1compile &apos;com.android.support:design:26.1.0&apos; xml布局文件12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;android.support.design.widget.FloatingActionButton android:id=&quot;@+id/fab&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; app:fabSize=&quot;auto&quot; app:elevation=&quot;1dp&quot; android:src=&quot;@mipmap/add&quot; android:clickable=&quot;true&quot; app:backgroundTint=&quot;#33ce33&quot; app:rippleColor=&quot;#0000ff&quot; /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; 使用简单,当做ImageBubbon使用,设置src 白色的”+”号. FloatingActionButton常用属性 app:fabSize:为了符合Material Design的设计风格，Google给出了FloatingActionButton的三种大小值：mini、normal、auto. app:elevation=”6dp”：为了有投影悬浮效果，为FloatingActionButton设置一个高度值.高度值越大，投影效果越淡，投影范围越大.高度值越小，投影效果越浓，投影范围越小. app:rippleColor：为了符合Material Design的设计风格，为了使可点击的选项给用户反馈，点击时会有水波纹扩散的效果.默认值是灰色的水波纹效果。如果设置rippleColor没有效果，记得设置属性android:clickable=”true”. app:pressedTranslationZ=”10dp”：设置阴影的点击效果。与elevation控制的同一地方的阴影，不过elevation是非按压时的阴影效果，而pressedTranslationZ是点击按钮时阴影的效果. app:backgroundTint： 改变FloatingActionButton的背景颜色. android:src: 设置FloatingActionButton的背景内容当然也可以在java代码中设置这些参数 总结FloatingActionButton使用简单,和ImageBotton类似,多一些ripple,投影效果]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Snackbar]]></title>
    <url>%2F2017%2F11%2F07%2FSnackbar%2F</url>
    <content type="text"><![CDATA[Snackbar是Android Support Design Library库中的一个控件，可以在屏幕底部快速弹出消息，比Toast更加好用。 导包使用Snackbar要导入com.android.support:design库。1compile &apos;com.android.support:design:26.1.0&apos; 一般使用Snackbar基本使用和Toast类似123456789Snackbar.make(view,&quot;hello world&quot;,Snackbar.LENGTH_INDEFINITE) .setAction(&quot;你好&quot;, new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; //点击后关闭Snackbar Toast.makeText(SnackbarActivity.this,&quot;Snackbar被点击了&quot;,Toast.LENGTH_LONG).show(); &#125; &#125;) .show(); 属性解析:make()生成Snackbar.第一个参数是容纳view,推荐使用CoordinatorLayout来确保Snackbar和其他组件的交互,比如向右右滑动Snackbar可取消,Snackbar出现时FloatingActionButton上移.第二个参数是提示内容.第三个参数是显示时间:LENGTH_SHORT、LENGTH_LONG和LENGTH_INDEFINITE。setAction()设置右侧按钮,可增加点击事件.如果不写setAction()则只显示左侧提示内容.下图演示右滑Snackbar取消和点击Action弹出Toast提示 颜色修改 Action 文字颜色修改.setActionTextColor(color)即可 修改Snackbar背景颜色api中并不能直接修改背景颜色,通过查看源码Snackbar加载了R.layout.design_layout_snackbar_include布局文件 12345678910111213141516171819202122232425262728293031&lt;merge xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;&lt;TextView android:id=&quot;@+id/snackbar_text&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_weight=&quot;1&quot; android:paddingTop=&quot;14dp&quot; android:paddingBottom=&quot;14dp&quot; android:paddingLeft=&quot;12dp&quot; android:paddingRight=&quot;12dp&quot; android:textAppearance=&quot;@style/TextAppearance.Design.Snackbar.Message&quot; android:maxLines=&quot;2&quot; android:layout_gravity=&quot;center_vertical|left|start&quot; android:ellipsize=&quot;end&quot; android:textAlignment=&quot;viewStart&quot;/&gt;&lt;Button android:id=&quot;@+id/snackbar_action&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;0dp&quot; android:layout_marginStart=&quot;0dp&quot; android:layout_gravity=&quot;center_vertical|right|end&quot; android:paddingTop=&quot;14dp&quot; android:paddingBottom=&quot;14dp&quot; android:paddingLeft=&quot;12dp&quot; android:paddingRight=&quot;12dp&quot; android:visibility=&quot;gone&quot; android:textColor=&quot;?attr/colorAccent&quot; style=&quot;?attr/borderlessButtonStyle&quot;/&gt;&lt;/merge&gt; TextView:Snackbar左侧的message,Button是右侧的Action修改Snackbar背景颜色和message字体颜色就是这样:1234567public static void setSnackbarColor(Snackbar snackbar, int messageColor, int backgroundColor) &#123; View view = snackbar.getView();//获取Snackbar的view if(view!=null)&#123; view.setBackgroundColor(backgroundColor);//修改view的背景色 ((TextView) view.findViewById(R.id.snackbar_text)).setTextColor(messageColor);//获取Snackbar的message控件，修改字体颜色 &#125;&#125; 简单修改代码就能改变背景颜色,message字体颜色123456789101112131415final Snackbar make = Snackbar.make(coordinatorLayout, &quot;hello world&quot;, Snackbar.LENGTH_INDEFINITE);setSnackbarColor(make,getResources().getColor(R.color.black),getResources().getColor(R.color.colorAccent));make.setActionTextColor(getResources().getColor(R.color.blue));tv.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; make.setAction(&quot;你好&quot;, new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Toast.makeText(SnackbarActivity.this,&quot;Snackbar Action被点击了&quot;,Toast.LENGTH_LONG).show(); &#125; &#125;) .show(); &#125;&#125;); 效果图:背景变成了红色,Message字体颜色为黑色,Action字体颜色蓝色 总结Snackbar使用和Toast很是相似,出现在所有屏幕其他元素之上,make()生成Snackbar,show()显示.可以设置action设置右侧按钮,增加交互Snackbar样式修改,可直接通过setActionTextColor()修改action按钮颜色,要想修改背景和message颜色,就需要snackbar.getView()修改背景颜色,findviewbyid修改snackbar_text颜色最后推荐Snackbar和CoordinatioLayout配合使用,以达到和其他组件(比如FloatingActionButton)交互效果,后面会讲到CoorinationLayout 参考:http://www.jianshu.com/p/cd1e80e64311/]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Toolbar]]></title>
    <url>%2F2017%2F11%2F06%2FToolbar%2F</url>
    <content type="text"><![CDATA[Toolbar简介ToolBar是Android 5.0推出的一个新的导航控件用于取代之前的ActionBar，由于其高度的可定制性、灵活性、具有Material Design风格等优点，越来越多的应用也用上了ToolBar，比如常用的知乎软件其顶部导航栏正是使用ToolBar。官方考虑到仍有一部分用户的手机版本号低于5.0，所以，ToolBar也放进了support v7包内，使得低版本的系统也能使用上ToolBar。本文将使用support v7支持包的ToolBar来进行讲解，包括其基本用法、样式定制等知识点。 引入support v7支持包1implementation &apos;com.android.support:appcompat-v7:26.1.0&apos; 更改主题需要使用此支持包内主题Theme.AppCompat12&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; &lt;/style&gt; xml布局文件1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;android.support.v7.widget.Toolbar android:id=&quot;@+id/tbar&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_title&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;tv标题&quot; /&gt; &lt;/android.support.v7.widget.Toolbar&gt;&lt;/RelativeLayout&gt; 效果图:Toolbar正常显示,没有设置背景色所以看不到具体高度.继续 属性设置背景颜色可以直接添加background,但是为了统一,使用?attr/colorPrimary. Toolbar中添加1android:background=&quot;?attr/colorPrimary&quot; title,subtitle,logo,navigation…123456Toolbar toolbar = findViewById(R.id.tbar);toolbar.setLogo(R.mipmap.ic_launcher);toolbar.setTitle(&quot;Title&quot;);toolbar.setSubtitle(&quot;Subtitle&quot;);setSupportActionBar(toolbar);//把toolbar作为操作栏,必不可少toolbar.setNavigationIcon(R.mipmap.nav); 效果图:如果你想修改标题和子标题的字体大小、颜色等，可以调用 setTitleTextColor 、 setTitleTextAppearance 、 setSubtitleTextColor 、 setSubtitleTextAppearance 这些API。 这些属性也可在.xml文件中设置12345&lt;android.support.v7.widget.Toolbar ... app:logo=&quot;@mipmap/ic_launcher&quot; app:subtitle=&quot;subtitle&quot; app:title=&quot;Title&quot;&gt; 添加菜单选项新建res/menu/menu_toolbar.xml123456789101112131415161718192021222324&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot;&gt; &lt;item android:id=&quot;@+id/share&quot; android:title=&quot;分析&quot; android:icon=&quot;@mipmap/share&quot; app:showAsAction=&quot;ifRoom&quot;/&gt; &lt;item android:id=&quot;@+id/search&quot; android:title=&quot;搜索&quot; android:icon=&quot;@mipmap/search&quot; app:showAsAction=&quot;ifRoom&quot;/&gt; &lt;item android:id=&quot;@+id/collection&quot; android:title=&quot;收藏&quot; android:icon=&quot;@mipmap/collection&quot; app:showAsAction=&quot;ifRoom&quot;/&gt; &lt;item android:id=&quot;@+id/setting&quot; android:title=&quot;设置&quot; app:showAsAction=&quot;never&quot;/&gt;&lt;/menu&gt; app:showAsAction=”ifRoom|never”;ifRoom:toolbar能放得下,就显示在toolbar,否则折叠到更多;never直接折叠到更多 Activity重新onCreateOptionMenu(),将此菜单加载进去12345@Overridepublic boolean onCreateOptionsMenu(Menu menu) &#123; getMenuInflater().inflate(R.menu.menu_toolbar,menu); return true;&#125; 效果图: 若没有出现menu,请检查是否有将toolbar作为操作栏:1setSupportActionBar(toolbar);//把toolbar作为操作栏,必不可少 添加点击事件1234567891011121314151617toolbar.setOnMenuItemClickListener(new Toolbar.OnMenuItemClickListener() &#123; @Override public boolean onMenuItemClick(MenuItem item) &#123; int itemId = item.getItemId(); String s = &quot;&quot;; switch (itemId)&#123; case R.id.share: s = &quot;share&quot;; break; case R.id.search: s = &quot;search&quot;; break; &#125; Toast.makeText(ToolBarActivity.this,s+&quot; 被点击&quot;,Toast.LENGTH_SHORT).show(); return true; &#125;&#125;); 样式修改(美化) 上图可以看出右边3个竖排圆点式黑色的,如果想修改为白色?主题中设置: android:textColorSecondary 1234&lt;style name=&quot;AppTheme&quot; parent=&quot;Theme.AppCompat.Light.NoActionBar&quot;&gt; ... &lt;item name=&quot;android:textColorSecondary&quot;&gt;#ffffff&lt;/item&gt;&lt;/style&gt; popup menu背景颜色字体颜色修改 1234&lt;!-- toolbar弹出菜单样式 --&gt;&lt;style name=&quot;ToolbarPopupTheme&quot; parent=&quot;@style/ThemeOverlay.AppCompat.Dark&quot;&gt; &lt;item name=&quot;android:colorBackground&quot;&gt;#000000&lt;/item&gt;&lt;/style&gt; toolbar添加属性1toolbar:popupTheme=&quot;@style/toolbarpopuptheme&quot; 效果图如此就能改变menu弹出菜单的背景颜色,同时文字颜色也会自动调整 修改popup menu 弹出位置默认情况popup menu覆盖在toolbar上,如上图.想要其在toolbar下方修改styles.xml: 1234567&lt;style name=&quot;ToolbarPopupTheme&quot; parent=&quot;@style/ThemeOverlay.AppCompat.Dark&quot;&gt; &lt;item name=&quot;android:colorBackground&quot;&gt;#000000&lt;/item&gt; &lt;item name=&quot;actionOverflowMenuStyle&quot;&gt;@style/OverflowMenuStyle&lt;/item&gt; &lt;!--新增一个item，用于控制menu--&gt;&lt;/style&gt;&lt;style name=&quot;OverflowMenuStyle&quot; parent=&quot;Widget.AppCompat.Light.PopupMenu.Overflow&quot;&gt; &lt;item name=&quot;overlapAnchor&quot;&gt;false&lt;/item&gt; &lt;!--把该属性改为false即可使menu位置位于toolbar之下--&gt;&lt;/style&gt; 效果图: 总结Toolbar使用比较简单(设置title,logo…,popup menu),美化.做个小结 向下兼容用v7包(引入support v7包) 主题使用v7包的Theme.AppCompay 一系列的参数设置(title,logo…),可以在代码中写,也可以做xml文件中写 添加菜单项:新建menu文件,Activity重写onCreateOptionMenu方法,并在此方法中加载menu menu点击事件setOnMenuItemClickListener() 样式修改(美化):更多选项图标颜色修改;popup menu背景颜色修改;弹出框弹出位置修改.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DrawerLayout]]></title>
    <url>%2F2017%2F11%2F03%2FDrawerLayout%2F</url>
    <content type="text"><![CDATA[DrawerLayout:抽屉布局;DrawerLayout + NavigationView 效果绝佳.使用DrawerLayout需要导入Design包1compile &apos;com.android.support:design:26.1.0&apos; .xml123456789101112131415161718192021222324252627&lt;android.support.v4.widget.DrawerLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:app=&quot;http://schemas.android.com/apk/res-auto&quot; android:id=&quot;@+id/dl&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot;&gt; &lt;RelativeLayout android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; android:paddingTop=&quot;@dimen/tool_bar_top_padding&quot; android:background=&quot;#33ff0000&quot;&gt; &lt;TextView android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;content&quot; android:textSize=&quot;24sp&quot;/&gt; &lt;/RelativeLayout&gt; &lt;android.support.design.widget.NavigationView android:id=&quot;@+id/nav&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; app:menu=&quot;@menu/draw_menu&quot; app:headerLayout=&quot;@layout/nav_headerlayout&quot;&gt; &lt;/android.support.design.widget.NavigationView&gt; 最外层是DrawerLayout,包含2部分内容:主内容一定要是DrawerLayout的第一个子视图,并且宽高都是math_parent[上例RelativeLayout为主内容];NavigationView为抽屉. 关键:此属性android:layout_gravity=”start”定义抽屉从左滑出,或”end”从右滑出,不推荐使用left和right.NavigationView:为导航菜单,后面会具体讲解. 监听事件DrawerLayout.DrawerLayoutListener作为监听器12345678910111213141516drawerLayout.addDrawerListener(new MyDrawerListener());private class MyDrawerListener implements DrawerLayout.DrawerListener&#123; public void onDrawerSlide(View drawerView, float slideOffset) &#123; //当抽屉被滑动时调用 滑动幅度0-1 &#125; public void onDrawerOpened(View drawerView) &#123; //抽屉完全被打开 &#125; public void onDrawerClosed(View drawerView) &#123; //抽屉完全被关闭 &#125; public void onDrawerStateChanged(int newState) &#123; //当抽屉状态改变时候被调用 //状态是state:0(闲置);1(拖拽);2(固定) &#125; &#125; 或设置DrawerListener的子类SimpleDrawerListener，使用这个类的时候不必实现全部的回调函数，可以根据自己的需要重写相应的方法。 NavigationView上例xml中的NavigationView可以换成别的来定义侧滑菜单部分,但是需要花费时间.使用NavigationView简单,统一.NavigationView分为两部分,上面一部分叫做HeaderLayout,下面的是Menu NavigationView属性上例NavigationView部分1234567&lt;android.support.design.widget.NavigationView android:id=&quot;@+id/nav&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;match_parent&quot; android:layout_gravity=&quot;start&quot; app:menu=&quot;@menu/draw_menu&quot; app:headerLayout=&quot;@layout/nav_headerlayout&quot;&gt; 属性解释: android:layout_gravity=”start”:表示该view从左侧滑出(end:右侧),必须指定. app:headerLayout=”@layout/nav_headerlayout”:引用一个头部布局,就是图1上面的蓝色背景部分,包含背景和用户名welau. app:menu=”@menu/draw_menu”:引用一个menu作为下面的点击项.HeaderLayout布局nav_headerlayout.xml:123456789101112131415&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;100dp&quot; android:background=&quot;#4400ffff&quot;&gt; &lt;TextView android:id=&quot;@+id/tv_headerlayout&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginLeft=&quot;10dp&quot; android:layout_marginTop=&quot;@dimen/tool_bar_top_padding&quot; android:text=&quot;welau&quot; android:textSize=&quot;24sp&quot; /&gt;&lt;/RelativeLayout&gt; Menu文件draw_menu.xml12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;item android:id=&quot;@+id/item1&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;定制&quot;/&gt; &lt;item android:id=&quot;@+id/item2&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;我的&quot;/&gt; &lt;item android:id=&quot;@+id/item3&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;设置&quot;/&gt; &lt;item android:id=&quot;@+id/item4&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;关于&quot;/&gt;&lt;/menu&gt; 看看效果问题:图片都变成了灰色!!! NavigationView布局中添加app:itemIconTint=”#f00”,那么图标就变成了红色!!! 使用原图显示,在java代码中设置:1navigationView.setItemIconTintList(null); 还有2个常用属性: app:itemBackground=”@color/colorAccent”设置item的背景颜色 app:itemTextColor=””设置item的文字颜色 Menu属性menu item间添加分割线:使用group,并给该group设置id(必须设置,不然无效)1234567891011121314151617181920212223&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;menu xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt; &lt;group android:id=&quot;@+id/g1&quot;&gt; &lt;item android:id=&quot;@+id/item1&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;定制&quot; /&gt; &lt;/group&gt; &lt;item android:id=&quot;@+id/item2&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;我的&quot; /&gt; &lt;item android:id=&quot;@+id/item3&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;设置&quot; /&gt; &lt;group android:id=&quot;@+id/g2&quot;&gt; &lt;item android:id=&quot;@+id/item4&quot; android:icon=&quot;@mipmap/ic_launcher&quot; android:title=&quot;关于&quot; /&gt; &lt;/group&gt;&lt;/menu&gt; 效果图: 事件处理头部点击事件获取头部控件HeaderLayout:例子中的nav_headerlayout.layout12//获取头布局文件 View headerView = navigationView.getHeaderView(0); 通过headerView.findViewById()获取HeaderLayout中的view123View headerView = navigationView.getHeaderView(0); TextView tv_name = headerView.findViewById(R.id.tv_name); tv_name.setText(&quot;header&quot;); 效果图: Menu item点击事件navigationView.setNavigationItemSelectedListener(NavigationItemSelectedListener)123456789101112131415161718navigationView.setNavigationItemSelectedListener(new NavigationView.OnNavigationItemSelectedListener() &#123; @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) &#123; int itemId = item.getItemId(); switch (itemId) &#123; case R.id.item1: Toast.makeText(DrawerLayoutActivity.this,&quot;item1被点击&quot;,Toast.LENGTH_LONG).show(); break; case R.id.item2: break; case R.id.item3: break; case R.id.item4: break; &#125; return true; &#125; &#125;); 效果图: 总结 DrawerLayout:抽屉布局,第一个Layout为主内容区域,侧滑菜单必须指定android:layout_gravity=”start|end”; DrawerLayout事件:drawerLayout.addDrawerListener(DrawerListener) 侧滑菜单可是自己写也可以使用NavigationView; NavigationView中app:headerLayout引入头部布局,常见app显示图片加文字; app:menu引入item; NavigationView 通过getHeaderView获取引入的头部布局; NavigationView menu item的点击事件:setNavigationItemSelectedListener()]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TextInputLayout]]></title>
    <url>%2F2017%2F11%2F03%2FTextInputLayout%2F</url>
    <content type="text"><![CDATA[TextInputLayout是用来增强Edittext[TextInputEditText]，使用的时候包裹Edittext。当edittext获取焦点是，edittext的hint值就会浮到edittext的上方;setError(str)下方出现提示 添加依赖TextInputLayout是在Material Design中的,如果我们要使用的话,必须在gradle文件中配置 1234dependencies &#123; compile &apos;com.android.support:appcompat-v7:25.0.1&apos; compile &apos;com.android.support:design:25.0.1&apos;&#125; 使用 （xml）1234567891011121314&lt;android.support.design.widget.TextInputLayout android:id=&quot;@+id/til_1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; app:layout_constraintEnd_toEndOf=&quot;parent&quot; app:layout_constraintStart_toStartOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot;&gt; &lt;EditText android:id=&quot;@+id/et_1&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;wrap_content&quot; android:hint=&quot;name&quot; /&gt; &lt;/android.support.design.widget.TextInputLayout&gt; 使用TextInputLayout包裹一个（只能是一个）EdiTtext。hint可以在TextInputLayout或EditText中设置。 属性说明浮动标签（hintEnable）若想关闭浮动标签（默认开启）：1app:hintEnable=&quot;false&quot; 浮动标签过渡动画浮动标签显示与隐藏之间有一个过渡动画(默认是开启的),可以通过以下方法设置1app:hintAnimationEnabled=&quot;false&quot; 计数器（counterEnable）如果我们想要在账号那栏后面加个字数统计,例如当我们的账号是固定位数时(例如手机号码,),我们可以让用户看到自己当前输入的长度,我们只需要在TextInputLayout加入1app:counterEnabled=&quot;true&quot; 设置最大长度1app:counterMaxLength=&quot;11&quot; 此属性并不能限制用户输入，而是用另一种颜色提示用户输入长度超过了设置长度 setError() 错误提示TextInputLayout提供了错误提示的方法，出现在EditText下方；setError（null）取消错误提示 密码可见按钮1app:passwordToggleEnabled=&quot;true&quot; //默认是关闭的 需要在子EditText中加入属性android:inpuTtype=”textPassword” 自定义密码可见按钮图标1app:passwordToggleDrawable=&quot;@mipmap/ic_launcher&quot; 密码可见按钮上色1app:passwordToggleTint=&quot;@color/colorAccent&quot; 密码可见按钮设置模式12//screen,src_in,src_atop,src_over,multiply等几种设计模式app:passwordToggleTintMode=&quot;screen&quot; //screen 自定义浮动标签1app:hintTextAppearance=&quot;@style/hintAppearance&quot; 1234&lt;style name=&quot;hintAppearance&quot; parent=&quot;TextAppearance.AppCompat&quot;&gt; &lt;item name=&quot;android:textSize&quot;&gt;14sp&lt;/item&gt; &lt;item name=&quot;android:textColor&quot;&gt;#ffee00&lt;/item&gt;&lt;/style&gt; 自定义错误提示样式1app:errorTextAppearance=&quot;@style/errorAppearance&quot; 1234&lt;style name=&quot;errorAppearance&quot; parent=&quot;TextAppearance.AppCompat&quot;&gt; &lt;item name=&quot;android:textSize&quot;&gt;14sp&lt;/item&gt; &lt;item name=&quot;android:textColor&quot;&gt;@color/red&lt;/item&gt;&lt;/style&gt; 补充（EditText 和 TextInputEditText区别）继承关系：123456java.lang.Object ↳ android.view.View ↳ android.widget.TextView ↳ android.widget.EditText ↳ android.support.v7.widget.AppCompatEditText ↳ android.support.design.widget.TextInputEditText TextInputEditText作为EditText的子类，为TextInputLayout设计的一个子容器。输入法在’extract’模式的时候，使用TextInputEditText类允许显示提示，而EditText则没有。上图，用户名使用的事EditText。密码使用的是TextInputEditText,可以看到输入的时候都变成了全屏模式，用户名使用EidtText的时候hint就隐藏了，而密码使用TextInputEditText的时候hint可以正常显示。由此可见TextInputEditText的设计就是修复了这个缺陷，所以TextInputLayout和TextInputEditText配合使用的效果最好! 总结TextInputLayout包裹EditText，帮助EditText做些事情：1.hint提到EditText头上去；2.错误提示放在下发；EditTEXT原本也有错误提示，在输入框右边；3.密码小眼睛（app:passwordToggleEnabled=”true”）。4.TextInputLayout应和TextInputEditText配合使用，不推荐配合EditText使用。 参考:http://blog.csdn.net/johnny901114/article/details/51918436http://www.jianshu.com/p/a9b48dee86e0]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConstraintLayout-进阶的RelativeLayout]]></title>
    <url>%2F2017%2F11%2F02%2FConstraintLayout-%E8%BF%9B%E9%98%B6%E7%9A%84RelativeLayout%2F</url>
    <content type="text"><![CDATA[伴随着Android Studio 2.2的正式推送,最大的亮点是布局的蓝图模式以及与之配套的ConstraintLayout关注度一下子高了起来. ConstraintLayout,翻译过来,可以叫约束布局,其子view就是通过一个个属性的约束,来决定自己的位置,大小,而传统的RelativeLayout也类似,所以可以看成是RelativeLayout的一种进化版版本,属性布局用法相对RelativeLayout来说较为复杂,但是当你熟悉之后你会爱上它的. 众所周知,Android APP的布局复杂度会极大的影响程序的流畅度,传统的ViewGroup用的最多的就是RelativeLayout与LineaLayout. 一般能用RelativeLayout替换LineaLayout就替换,因为LinearLayout虽然简单,但是会加深层级. 而有时候却不得不使用LinearLayout,在于LinearLayout有一个layout_weight属性,可以设置LinearLayout的ChildView按照一定的比例布局,这是RelativeLayout做不到的. ConstraintLayout的其他的属性和用法基本与RelativeLayout一致,如果对RelativeLayout比较熟悉的童鞋很容易上手,而ConstraintLayout最大的优点便是可以添加比例的控制. 概念ConstraintLayout约束布局的含义: 根据布局中的其他元素或视图, 确定View在屏幕中的位置, 受到三类约束, 即其他视图, 父容器(parent), 基准线(Guideline).1layout_constraint[本源位置]_[目标位置]=&quot;[目标ID]&quot; 例如：1app:layout_constraintBottom_toBottomOf=&quot;@+id/constraintLayout&quot; 约束当前View的底部至目标View的底部, 目标View是constraintLayout. 即, 把当前View的底部对齐到constraintLayout的底部. 基本约束属性ConstraintLayout是RelativeLayout的进化版,如果RelativeLayout的子view没有设置任何基本属性,则置于左上角,ConstraintLayout同理. ConstraintLayout基本属性的值可以是某个控件的id,也可以是”parent”,简单的概括就是top,bottom,left,right,baseline. 约束属性值为id时对照表 约束属性值等于parent当基本属性值为parent时,必须成对出现才有意义,即top与bottom,left与right,start与end成对. 比例属性闪亮登场12layout_constraintHorizontal_bias=&quot;0.4&quot;layout_constraintVertical_bias=&quot;0.6&quot; 这两个属性接受浮点型,是一个比例,数值在0-1之间,如不写这属性,默认为0.5 点击左下角切换的Design,再点击Button选中这个控件,右边栏会出现约束属性图 属性理解： 箭头向里 表示控件的宽度/高度是适应内容的,弹簧状（“工”字形） 表示控件是宽度/高度是具体数值 上下两个0表示控件的上下margin是0dp 小球50这个数值表示在垂直方向上,上下的比例是0.5:0.5鼠标拖动小球,上下移动会发现数值,控件垂直方向上的位置都跟着改变.拖动到20,切换到代码,会发现代码新增了一个属性,此时控件的上下比例是:0.21app:layout_constraintVertical_bias=&quot;0.2&quot; 控件大小比例属性1app:layout_constraintDimensionRatio=&quot;1:2&quot; 子view控制自身的宽高比（宽高1:2）**注意： 这个属性生效需要以下条件：left，right，top，bottom 四条边中至少一个约束 宽高有且只有一个是0dp** Guideline导航线123app:layout_constraintGuide_begin=&quot;50dp&quot;app:layout_constraintGuide_end=&quot;50dp&quot;app:layout_constraintGuide_percent=&quot;50&quot; 介绍导航线之前,先想一下,根据上面对ConstraintLayout的介绍,要你布置一个菜单控件,菜单栏每一项均分屏幕宽度,按照以前使用LinearLayout,会把每一个子view的weight设置为1,则均分了屏幕宽度12345&lt;LinearLayout&gt; &lt;View/&gt; &lt;View/&gt; &lt;View/&gt;&lt;/LinearLayout&gt; 而使用ConstraintLayout则会发现前面介绍的比例,是相对parent来说的,如果要均分屏幕宽度,必须借助透明的分割线来布局1234567&lt;ConstraintLayout&gt; &lt;View,右边约束分割线1/&gt; &lt;分割线1,距离左边33%/&gt; &lt;View,左边约束分割线1,右边约束分割线2/&gt; &lt;分割线2,距离左边66%/&gt; &lt;View,左边约束分割线2/&gt;&lt;/ConstraintLayout&gt; 而这个分割线其实谷歌已经帮我们写好了,就是Guideline.蓝图介绍中,6对应的就是添加导航线.切换到蓝图模式,点击6,就可以添加一个水平/垂直的导航线 添加垂直导航线 Guideline属性对照表 Guideline属性值 Guideline本身对于用户来说是不可见的,所以其宽高的值没有任何意义,也不起作用.1234567&lt;android.support.constraint.Guideline android:id=&quot;@+id/guideline&quot; android:layout_width=&quot;wrap_content&quot;//无意义 android:layout_height=&quot;10dp&quot;//无意义 android:orientation=&quot;vertical&quot;//决定这是一条水平导航线还是垂直导航线 app:layout_constraintGuide_percent=&quot;0.333&quot;//决定导航线的位置/&gt; 此时再添加一条比例为0.666的导航线,即可三等分屏幕 总结有了GuideLine就可以抛弃LinearLayout。单单使用ConstraintLayout写布局，减少布局层级。 参考：http://www.jianshu.com/p/d64d845b6b90]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android material design组件学习]]></title>
    <url>%2F2017%2F11%2F02%2Fandroid-material-design%E7%BB%84%E4%BB%B6%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[TextInputLayoutToolbarDrawerLayoutSnackbarFloatingActionButtonTabLayoutCoordinatorLayout]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android material design]]></title>
    <url>%2F2017%2F11%2F02%2Fandroid-material-design%2F</url>
    <content type="text"><![CDATA[核心思想material design的核心思想，就是把物理世界的体验带进屏幕。去掉现实中的杂质和随机性，保留其最原始纯净的形态、空间关系、变化与过渡，配合虚拟世界的灵活特性，还原最贴近真实的体验，达到简洁与直观的效果。 参考：http://www.uisdc.com/comprehensive-material-design-note]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Material Design</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GreenDao 使用]]></title>
    <url>%2F2017%2F05%2F27%2FGreenDao-%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[GreenDao是一个对象关系映射（ORM）的框架，能够提供一个接口通过操作对象的方式去操作关系型数据库，它能够让你操作数据库时更加单、方便。 GreenDao 优点 性能高，号称Android最快的关系型数据库 内存占用小 库文件比较小，小于100k，编译时间短，而且可以避免65k方法限制 支持数据库加密 简洁易用的API GreenDao 3.0使用方法引入依赖Project build.gradle123456repositories &#123; mavenCentral()&#125;dependencies &#123; classpath &apos;org.greenrobot:greendao-gradle-plugin:3.2.2&apos;&#125; app build.gradle123456789apply plugin: &apos;org.greenrobot.greendao&apos;android &#123; greendao &#123; schemaVersion 1 //版本 daoPackage &apos;om.example.test.db&apos; // 一般为app包名+生成文件的文件夹名 targetGenDir &apos;src/main/java&apos; //生成文件路径 &#125;&#125; 新建实体类（Shop）1234567891011121314@Entitypublic class Shop &#123; @Id(autoincrement = true) private Long id;//id 主键 自增 @Unique private String name;//商品名称 唯一 @Property(nameInDb = &quot;price&quot;)//自定义字段名 private String pro_price; private int sell_num;//销售数量&#125; 注解解释： @entity：告诉GreenDao该对象为实体，只有被@Entity注释的Bean类才能被dao类操作 @id：对象的id，必须使用Long类型作为id，否则会报错 @Property：可以自定义字段名，注意外键不能使用该属性 @NotNull：属性不能为空 @Transient：使用该注释的属性不会被存入数据库的字段中 @Unique：唯一值 @Generated：编译后自动生成的构造函数、方法等的注释，提示构造函数、方法等不能被修改 此时编译一下，自动生成Shop实体的构造方法和get、set方法，自动生成DaoMaster、DaoSession、ShopDao，在前面配置文件’daoPackage’，’targetGenDir’目录下 此时相当于已经建好了数据表和字段都建好了，下面需要创建数据库。 创建数据库（数据库名）在程序启动的时候就去创建数据库1234567891011121314151617181920212223242526272829public class BaseApplication extends Application &#123; private static DaoSession daoSession; @Override public void onCreate() &#123; super.onCreate(); //配置数据库 setupDatabase(); &#125; /** * 配置数据库 */ private void setupDatabase() &#123; //创建数据库shop.db&quot; DaoMaster.DevOpenHelper helper = new DaoMaster.DevOpenHelper(this, &quot;shop.db&quot;, null); //获取可写数据库 SQLiteDatabase db = helper.getWritableDatabase(); //获取数据库对象 DaoMaster daoMaster = new DaoMaster(db); //获取Dao对象管理者 daoSession = daoMaster.newSession(); &#125; public static DaoSession getDaoInstant() &#123; return daoSession; &#125;&#125; DevOpenHelper：创建SQLiteOpenHepler的具体实现DaoMaster：GreenDao的顶级对象，作为数据库对象，用于创建表和删除表DaoSession：管理所有的Dao对象，Dao对象中存在着增删改查等API 数据库的增删改查12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class LoveDao &#123; /** * 添加数据，如果有重复则覆盖 * * @param shop */ public static void insertLove(Shop shop) &#123; BaseApplication.getDaoInstant().getShopDao().insertOrReplace(shop); &#125; /** * 删除数据 * * @param id */ public static void deleteLove(long id) &#123; BaseApplication.getDaoInstant().getShopDao().deleteByKey(id); &#125; /** * 更新数据 * * @param shop */ public static void updateLove(Shop shop) &#123; BaseApplication.getDaoInstant().getShopDao().update(shop); &#125; /** * 查询条件为Type=TYPE_LOVE的数据 * * @return */ public static List&lt;Shop&gt; queryLove() &#123; return BaseApplication.getDaoInstant().getShopDao().queryBuilder().where(ShopDao.Properties.Type.eq(Shop.TYPE_LOVE)).list(); &#125; /** * 查询全部数据 */ public static List&lt;Shop&gt; queryAll() &#123; return BaseApplication.getDaoInstant().getShopDao().loadAll(); &#125;&#125; 操作介绍增加单个数据12insert(shop)insertOrReplace(shop) 增加多个数据12insertInTx(shopList)insertOrReplaceInTx(shopList) 查询全部12loadAll()queryBuilder().list() 查询附加单个/多个条件12where(，，)whereOr(，，) 查询附加排序12orderDesc()orderAsc() 查询限制当页个数1limit() 查询总个数1count() 修改单个/多个数据12update(shop)updateInTx(shops) 删除单个/多个数据/ByKey123delete(shop)deleteInTx(shops)deleteByKey(id)]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android 第三方框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http和https的区别]]></title>
    <url>%2F2017%2F05%2F25%2Fhttp%E5%92%8Chttps%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[HTTPS（基于安全套接字层的超文本传输协议 或者是 HTTP over SSL）是一个Netscape开发的Web协议。也可以说：HTTP = HTTP + SSLHTTPS 在 HTTP 应用层的基础上使用安全套接字层作为自层 TCP 三次握手、四次挥别：三次握手第一次握手：host1发送一个tcp标识位syn=1、ack=0的数据包给host2，并随机生成一个sequence number=3233.当host2接收到这个数据后，host2有syn=1可知host1是想建立连接；第二次握手：host2对host1的请求进行确认，向host1发送应道好syn=1、ack=1、确认号ack newber=3234（此值是host1的序列化+1），并随机生成一个sequence number=36457，这样就告诉host1可以进行连接；第三次握手：host1收到数据后检查ack nmuber是否是3233+1的值，以及ack的值是否为1，若为1，host1会发送ack=1、确认号码ack number=36457，告诉host2，你的请求连接被确认，连接可以建立。 四次挥别第一次挥手：当传输的数据到达尾部时，host1向host2发送fin=1标志位；可理解为host1向host2说，我这边的数据传送完了，我准备断开连接；第二次挥手：因为tcp的连接是全双工的双向连接，关闭也是要从两边关闭，当host2收到host1发来的fin=1的标志位后，host2不会立刻向host1发送find=1的请求关闭信息，而是先向host1发送一个ack=1的应答信息；表示你请求关闭的请求我收到了，但我可能还有数据没有传送完，你再等下，等我数据传输完成了我就告诉你；第三次挥手：host2完成了数据传输，向host1发送fin=1，host收到请求关闭连接的请求后，host1就明白host2的数据传输完成了，现在可以断开连接了；第四次挥手：host1收到fin=1后，host1还是怕网络不稳定等原因，怕host2不知道他要断开连接，于是向host2发送ack=1确认信息进行确认，把自己设置成time_wait状态并启动定时器，若果host2没有收到ack，host2端tcp的定时器到达后，会要求host重新发送ack，当host收到ack后，host2就断开连接；当host等待2mls（2倍报文最大生存时间）后，没有收到host2的重传请求后，他就知道host2已收到ack，所以host1此时才关闭自己的连接。 OSI 网络模型OSI网络模型：开放式通信系统互联参考模型。物理层，数据链路层，网络层，传输层，会话层，表示层，应用层。 http 和 https的不同之处 http的url以http://开头，而https 以https://开头 http是不安全的，而https是安全的 http的标准端口是80，https的是443 在osi网络模型中，http工作于应用层，而https工作于传输层 http无需加密，而https对传输的数据进行加密 http无需证书，而https需要认证证书 什么时候该使用https？银行网站、支付网关、购物网站、登录页、电子邮件以及一些企业部门的网站应用应该使用https]]></content>
      <tags>
        <tag>Http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git 使用]]></title>
    <url>%2F2017%2F05%2F21%2Fgit-%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[上传本地代码1.新建repository:2.把github上面的仓库克隆到本地git clone https://github.com/xxx/xxx.git（https://github.com/xxx/xxx.git仓库地址）这个步骤以后你的本地项目文件夹下面就会多出个文件夹，该文件夹名即为你github上面的项目名然后把要上传的项目复制到本地项目文件夹中3.git add .4.git commit -m “提交信息”5.git pull origin master6.git push -u origin master 更新代码1.git status(查看当前的git仓库状态)2.git add *(更新全部)3.git commit -m “更新说明”4.git pull(先git pull,拉取当前分支最新代码)5.git push origin master(push到远程master分支上) 参考上传本地代码及更新代码到GitHub教程]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 性能优化]]></title>
    <url>%2F2017%2F05%2F02%2FAndroid-%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前段时间公司主抓性能优化工作，借此春风也学习到了许多Android性能优化方面的知识。由于组内队友的给力，优化的成果也是比较喜人。同时也学习和实践了不少知识，特此记录。 性能优化分析工具Android Profiler 布局优化 减少布局嵌套 列表控件优化 使用include标签 算法优化查询考虑二分查找节省时间，尽量不要使用耗时的递归算法。必要的时候可以空间换时间来提高APP运行效率。 谨慎使用抽象编程抽象编程方式更加面向对象，需要编写额外的代码，虽然这些代码不会执行，但是却也要映射到内存当中会，不仅占用了更多内存，在执行效率上也会有所降低 其他优化 异步处理耗时操作 替换矢量图：矢量图消耗内存 减少冗余log 尽量避免使用依赖注入框架 使用ProGuard简化代码 内存泄露5中常见内存泄露及解决办法 单例造成的内存泄露Android的单例模式非常受开发者的喜爱，不过使用的不恰当的话也会造成内存泄漏。因为单例的静态特性使得单例的生命周期和应用的生命周期一样长，这就说明了如果一个对象已经不需要使用了，而单例对象还持有该对象的引用，那么这个对象将不能被正常回收，这就导致了内存泄漏。 如果单例中需要传入context，如果传入Application的context，将没有问题，因为单例的生命周期和application的一样长； 如果传入Activity的context，当这个context所对应的Activity退出时，单例对象持有该Activity的引用不会被回收。 非静态内部类创建静态实例123456789101112131415public class MainActivity extends AppCompatActivity &#123; private static TestResource mResource = null;//*** @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); if(mManager == null)&#123; mManager = new TestResource(); &#125; //... &#125; class TestResource &#123; //... &#125;&#125; 该静态实例一直会持有该Activity的引用，导致Activity不能正常回收 Handler造成内存泄露12345678910111213141516171819public class MainActivity extends AppCompatActivity &#123; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; //... &#125; &#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); loadData(); &#125; private void loadData()&#123; //...request Message message = Message.obtain(); mHandler.sendMessage(message); &#125;&#125; 这种写法就会造成内存泄露，由于mHandler是Handler的非静态匿名内部类的实例，所以它持有外部Activity的引用。消息队列是在一个Looper线程中不断轮询处理，当Activity退出消息队列还有未处理或正在处理消息，而消息队列中的Message持有mHandler实例的引用，mHandler又持有Activity的引用，所以导致该Activity无法及时回收。12345678910111213141516171819private MyHandler mHandler = new MyHandler(this);private static class MyHandler extends Handler &#123; private WeakReference&lt;Context&gt; reference; public MyHandler(Context context) &#123; reference = new WeakReference&lt;&gt;(context); &#125; @Override public void handleMessage(Message msg) &#123; MainActivity activity = (MainActivity) reference.get(); if(activity != null)&#123; activity.mTextView.setText(&quot;&quot;); &#125; &#125;&#125;@Overrideprotected void onDestroy() &#123; super.onDestroy(); mHandler.removeCallbacksAndMessages(null);&#125; 线程造成内存泄露123456789101112131415//——————test1 new AsyncTask&lt;Void, Void, Void&gt;() &#123; @Override protected Void doInBackground(Void... params) &#123; SystemClock.sleep(10000); return null; &#125; &#125;.execute();//——————test2 new Thread(new Runnable() &#123; @Override public void run() &#123; SystemClock.sleep(10000); &#125; &#125;).start(); 上面的异步任务和Runable都是一个匿名内部类，因此它们对当前Activity都有一个隐式引用。如果Activity在销毁之前，任务还未完成，那么将导致Activity内存无法被回收，造成内存泄露。正确做法还是使用静态内部类12345678910111213141516171819202122232425262728293031static class MyAsyncTask extends AsyncTask&lt;Void, Void, Void&gt; &#123; private WeakReference&lt;Context&gt; weakReference; public MyAsyncTask(Context context) &#123; weakReference = new WeakReference&lt;&gt;(context); &#125; @Override protected Void doInBackground(Void... params) &#123; SystemClock.sleep(10000); return null; &#125; @Override protected void onPostExecute(Void aVoid) &#123; super.onPostExecute(aVoid); MainActivity activity = (MainActivity) weakReference.get(); if (activity != null) &#123; //... &#125; &#125; &#125; static class MyRunnable implements Runnable&#123; @Override public void run() &#123; SystemClock.sleep(10000); &#125; &#125;//—————— new Thread(new MyRunnable()).start(); new MyAsyncTask(this).execute(); 这样就避免了Activity的内存资源泄漏，当然在Activity销毁时候也应该取消相应的任务AsyncTask::cancel()，避免任务在后台执行浪费资源。 资源未关闭使用了BroadcastReceiver，ContentObserver,File,Cursor,Stream,Bitmap等资源时，应该在Activity销毁时及时关闭或者注销]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2016%2F07%2F07%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[介绍因程序需要，有时候我们只需要某个类同时保留一个对象，不希望有更多对象，此时，需要用单例模式设计。单例模式特点： 只能有一个实例 单例类必须创建自己唯一的实例 单例类必须向其他对象提供这一实例 单例模式实现方式1. 饿汉模式123456//饿汉模式private static SingletonDemo singletonDemo = new SingletonDemo();private SingletonDemo() &#123;&#125;public static SingletonDemo getInstance()&#123; return singletonDemo;&#125; 在运行这个类的时候进行一次loading，之后直接访问 2. 懒汉模式123456789//懒汉模式private static SingletonDemo singletonDemo;private SingletonDemo() &#123;&#125;public static SingletonDemo getInstance()&#123; if (null == singletonDemo)&#123; singletonDemo = new SingletonDemo(); &#125; return singletonDemo;&#125; 线程不安全 3. 线程安全的懒汉模式12345678private static SingletonDemo singletonDemo;private SingletonDemo() &#123;&#125;public synchronized static SingletonDemo getInstance()&#123; if (null == singletonDemo)&#123; singletonDemo = new SingletonDemo(); &#125; return singletonDemo;&#125; 使用synchronized线程安全了，但并发时这个锁占用了额外的资源，效率低 4. DCL(双重校验锁法)123456789101112private volatile static SingletonDemo singletonDemo; //声明成 volatileprivate SingletonDemo() &#123;&#125;public static SingletonDemo getInstance()&#123; if (null == singletonDemo)&#123;//第一次校验 synchronized (SingletonDemo.class)&#123; if (null == singletonDemo)&#123;//第二次校验 singletonDemo = new SingletonDemo(); &#125; &#125; &#125; return singletonDemo;&#125; 两次判断,这段代码看起来很完美，很可惜，它是有问题。主要在于instance = new Singleton()这句，这并非是一个原子操作，事实上在 JVM 中这句话大概做了下面 3 件事情。 给 instance 分配内存 调用 Singleton 的构造函数来初始化成员变量 将instance对象指向分配的内存空间（执行完这步 instance 就为非 null 了) 但是在 JVM 的即时编译器中存在指令重排序的优化。也就是说上面的第二步和第三步的顺序是不能保证的，最终的执行顺序可能是 1-2-3 也可能是 1-3-2。如果是后者，则在 3 执行完毕、2 未执行之前，被线程二抢占了，这时 instance 已经是非 null 了（但却没有初始化），所以线程二会直接返回 instance，然后使用，然后顺理成章地报错。我们只需要将 instance 变量声明成 volatile 就可以了。* 5. 静态内部类12345678//静态内部类private SingletonDemo() &#123;&#125;private static class SingletonHolder&#123; private static SingletonDemo singletonDemo = new SingletonDemo();&#125;public static SingletonDemo getInstance()&#123; return SingletonHolder.singletonDemo;&#125; 好处：内部类不会再类加载的时候就加载，而是在调用getInstance()方法时才加载，达到了懒汉模式的效果，而这种方式又是线程安全的 6. 枚举123456789public enum SingletonDemo2 &#123; INSTANCE; public void test()&#123; Log.d(&quot;TAG&quot;,&quot;枚举法单例&quot;); &#125;&#125;//调用方法SingletonDemo2.INSTANCE.test(); 好处：①自由序列化 ②保证只有一个实例 ③线程安全 推荐使用4 5 6这三种方式]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service两种启动方式的区别]]></title>
    <url>%2F2016%2F06%2F20%2FService%E4%B8%A4%E7%A7%8D%E5%90%AF%E5%8A%A8%E6%96%B9%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[启动服务的两种方式startService（Intent）bindService（Intent，ServiceConnection，Int） startService方式采用start的方式开启服务步骤： 定义一个类继承Service 在ManiFest.xml文件中配置该Service 使用Context.startService(Intent)方法启动该Service 不再使用时，调用stopService(Intent)方法停止该服务 使用这个start方式启动的Service的生命周期：1onCreate -&gt; onStartCommand -&gt; onDestory 如果服务已经开启，不会重复的执行onCreate，而是调用onStartCommand。服务停止的时候调用onDestory，服务只会被停止一次。 特点：start方式 一旦服务开启，跟调用者就没有任何关系了，调用者退出，挂了，服务还在后台长期的运行，调用者不能调用服务里的方法。 bindService采用bind的方式开启服务步骤： 定义一个类继承Service 在Manifest.xml文件中配置该Service 使用Context的bindService(Intent，ServiceConnection，flags)方法启动服务 不再使用时，调用unbindService(ServiceConnection)方法停止该服务 使用bindService方式启动的Service的生命周期如下：1onCreate -&gt; onBind -&gt; onunbind -&gt; onDestory 注意：绑定服务不会调用onStartCommand（）方法。 特点：bind的方式开启服务，绑定服务，调用者挂了，服务也会跟着挂掉。绑定者可以调用服务里的方法。 绑定者调用服务里的方法首先定义一个Service的子类。123456789101112131415161718192021222324public class MyService extends Service &#123; private MyBinder myBinder; @Override public void onCreate() &#123; super.onCreate(); myBinder = new MyBinder(); &#125; @Override public IBinder onBind(Intent intent) &#123; return myBinder; &#125; public class MyBinder extends Binder &#123; public void test()&#123; Log.d(&quot;TAG&quot;,&quot;test()&quot;); &#125; &#125; &#125; 绑定服务的Activity：1234567891011121314151617181920212223242526272829public class MainActivity extends AppCompatActivity &#123; private MyService.MyBinder binder; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); View tv = findViewById(R.id.tv); tv.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; binder.test(); &#125; &#125;); MyServiceConn myServiceConn = new MyServiceConn(); bindService(new Intent(this,MyService.class),myServiceConn,BIND_AUTO_CREATE); &#125; public class MyServiceConn implements ServiceConnection&#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; binder = (MyService.MyBinder) service; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123;&#125; &#125; &#125; 绑定服务调用的方法步骤： 在服务创建一个类MyBinder继承自Binder（因为onBind（）需要返回一个IBinder，Binder实现了IBinder） onCreate（）里面实例化MyBinder 在MyBinder里创建一个供调用的方法 在activity 绑定服务。bindService() 在服务成功绑定的回调方法onServiceConnected， 会传递过来一个 IBinder对象 强制类型转化为自定义的MyBinder类型，调用类里面的方法。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[UML 统一建模语言]]></title>
    <url>%2F2016%2F06%2F16%2FUML-%E7%BB%9F%E4%B8%80%E5%BB%BA%E6%A8%A1%E8%AF%AD%E8%A8%80%2F</url>
    <content type="text"><![CDATA[通过使用UML的面向对象图的方式来更明确、清晰的表达项目中的架设思想、项目结构、执行顺序等一些逻辑思维 UML建模工具Rational Rose、PowerDesigner、Visual Paradigm for UML、Jude、SystemArchitect、StarUML UML统一了什么UML统一了Booch、OMT、OOSE和其他面向对象方法所涉及的基本概念和建模符号。 UML模型UML的模型主要由三部分构成： 事物：UML模型中最基本的构成元素，是具有代表性的成分的抽象 关系：关系把事物紧密联系在一起 图：图是事物和关系的可视化表示 UML特点 面向对象 可视化，表达能力强 独立于过程 独立于程序设计 容易掌握使用 UML 5种类图定义 用例图： 从用户角度描述系统功能，并指定各功能的操作者 静态图：包括类图，包图，对象图 行为图：描述系统动态模型和对象组成的交换关系。包括状态图和活动图 交互图：描述对象之间的交互关系 实现图：定义系统中软硬件的物理体系结构 UML 10种模型图 用例图：展示系统外部的各类执行者和系统提供的各种用例之间的关系 类图：展示系统中类的静态结构 对象图：是类图的一种实例化图 包图：是一种分组机制 状态图：描述一类对象具有的所有可能的状态及其转移关系 时序图：展示对象之间的一种动态协作关系 合作图：从另一个角度展示对象之间的动态协作关系 活动图：展示系统中各种活动的执行流程 构件图：展示程序代码的物理结构 配置图：展示软件在硬件环境中的配置关系]]></content>
      <categories>
        <category>项目管理</category>
      </categories>
      <tags>
        <tag>UML建模</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[排序算法]]></title>
    <url>%2F2016%2F05%2F28%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[冒泡排序原理：比较两个相邻的元素，将值大的元素交换至右端。思路：依次比较相邻的两个数，将小的数放在前面，大的数放在后面。即第一趟：比较1.和2.两个数，将小数放前，大数放后。然后比较2.和3.，将小数放前，大数放后；直至比较最后两个数；重复第一趟步骤，直至全部排序完成。举例说明：要排序数组：int[] arr = {6,3,8,2,9,1} 第一趟排序： 第一次排序：6和3比较，6大于3，交换位置： 3 6 8 2 9 1 第二次排序：6和8比较，6小于8，不交换位置：3 6 8 2 9 1 第三次排序：8和2比较，8大于2，交换位置： 3 6 2 8 9 1 第四次排序：8和9比较，8小于9，不交换位置：3 6 2 8 9 1 第五次排序：9和1比较：9大于1，交换位置： 3 6 2 8 1 9 第一趟总共进行了5次比较， 排序结果： 3 6 2 8 1 9 第二趟排序： 第一次排序：3和6比较，3小于6，不交换位置：3 6 2 8 1 9 第二次排序：6和2比较，6大于2，交换位置： 3 2 6 8 1 9 第三次排序：6和8比较，6大于8，不交换位置：3 2 6 8 1 9 第四次排序：8和1比较，8大于1，交换位置： 3 2 6 1 8 9 第二趟总共进行了4次比较， 排序结果： 3 2 6 1 8 9 第三趟排序： 第一次排序：3和2比较，3大于2，交换位置： 2 3 6 1 8 9 第二次排序：3和6比较，3小于6，不交换位置：2 3 6 1 8 9 第三次排序：6和1比较，6大于1，交换位置： 2 3 1 6 8 9 第二趟总共进行了3次比较， 排序结果： 2 3 1 6 8 9 第四趟排序： 第一次排序：2和3比较，2小于3，不交换位置：2 3 1 6 8 9 第二次排序：3和1比较，3大于1，交换位置： 2 1 3 6 8 9 第二趟总共进行了2次比较， 排序结果： 2 1 3 6 8 9 第五趟排序： 第一次排序：2和1比较，2大于1，交换位置： 1 2 3 6 8 9 第二趟总共进行了1次比较， 排序结果： 1 2 3 6 8 9 最终结果：1 2 3 6 8 9 由此可见：N个数字排序完成，总共进行N-1趟排序，每i趟的排序次数为（N-i）次，所以用双重循环语句，外层控制循环多少趟，内层控制每趟的循环次数，即123456789for (int i=0;i&lt;a.length-1;i++)&#123;//外层循环控制排序趟数 for(int j=0;j&lt;a.length-1-i;j++)&#123;//内层循环控制每一趟排序多少次 if (a[j]&gt;a[j+1])&#123; temp = a[j]; a[j] = a[j+1]; a[j+1]=temp; &#125; &#125;&#125; 冒泡排序的优点：每进行一趟排序，就会少比较一次，因为每进行一趟排序就会找出一个较大值 优化数据的顺序拍好之后，]]></content>
  </entry>
  <entry>
    <title><![CDATA[基本知识讲解]]></title>
    <url>%2F2016%2F05%2F23%2F%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E8%AE%B2%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[本节讲解android的基本知识：Activity启动过程、启动模式；Service启动方式；BroadCast注册；进程通信；缓存；mvp框架；JNI；View；WebView；内存优化；设计模式；开源框架… Activity的启动过程Activity启动模式及应用场景Activity启动模式及应用场景 延伸：栈与队列]]></content>
  </entry>
  <entry>
    <title><![CDATA[BroadcastReceiver 广播]]></title>
    <url>%2F2016%2F05%2F22%2FBroadcastReceiver-%E5%B9%BF%E6%92%AD%2F</url>
    <content type="text"><![CDATA[在Android中，我们如果想接收到广播信息，必须自定义我们的广播接收者。要写一个类继承自BroadcastReceiver，并且重写其onReceive（）方法，实现接收到特定广播所要做的事情。 广播接收者1234567public class MyReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; //在这里可以写相应的逻辑来实现一些功能 //可以从Intent中获取数据、还可以调用BroadcastReceiver的getResultData()获取数据 &#125;&#125; 我们已经定义好了一个广播接收者。要想使用它接收到广播，就要注册这个广播接收者。 有两种方式祖册广播： 代码中动态注册 实例化自定义的广播接收者 实例化意图过滤器，并设置要过滤的广播类型 使用Context的registReceiver（）方法注册广播 代码：123MyReceiver myReceiver = new MyReceiver();IntentFilter intentFilter = new IntentFilter(Intent.ACTION_SCREEN_ON);//系统解锁广播registerReceiver(myReceiver,intentFilter); 在Manifest.xml中静态注册直接在Manifest.xml文件配置广播接收者。12345&lt;receiver android:name=&quot;.receiver.MyReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;android.intent.action.SCREEN_ON&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 两种注册方式的不同第一种不是常驻广播，跟随程序的生命周期；第二种是常驻广播，当程序关闭时，还是会接收到广播。 广播的发送当我们需要发送一个自定义的广播来通知程序中其他组件的一些状态是，就可以使用发送一条广播的方式。 注册一个接收消息的广播123456789MyReceiver myReceiver = new MyReceiver();IntentFilter intentFilter = new IntentFilter(&quot;test&quot;);//action名字可随意registerReceiver(myReceiver,intentFilter);或&lt;receiver android:name=&quot;.receiver.MyReceiver&quot;&gt; &lt;intent-filter&gt; &lt;action android:name=&quot;test&quot;/&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 发送广播1sendBroadcast(new Intent().setAction(&quot;test&quot;)); 发送无序广播：context.sendBroadcast(intent)或context.sendBroadcast(intent,string)发送有序广播：context.sendOrderBroadcast(…) 区别：无序广播：所有接收者都会接收到事件，不可以被拦截，不可以被修改；有序广播：按照优先级，一级一级的向下传递，接收者可以修改广播数据，也可以终止广播事件。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Junit 单元测试]]></title>
    <url>%2F2016%2F05%2F19%2FJunit-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[单元测试（unit testing），是指对软件中的最小可测试单元进行检查和验证。比如一个函数，一个方法等。 添加junit依赖1testImplementation &apos;junit:junit:4.12&apos; 写一个要测试的类1234567public class Calculator &#123; public int add(int one, int another) &#123; return one + another; &#125;&#125; 写测试类手动写测试类单元测试代码放在src/test/java目录下12345678910public class CalculatorTest &#123; @Test public void testAdd() throws Exception &#123; Calculator calculator = new Calculator(); int sum = calculator.add(1, 2); assertEquals(3, sum); &#125;&#125; 右键testAdd方法，run “testAdd()” 使用快捷方式自动创建测试类选择目标类或目标方法，点击右键，选择GoTo -&gt; Test，来快速创建单元测试方法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Junit 单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 多线程]]></title>
    <url>%2F2016%2F04%2F28%2FAndroid-%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[当我们启动一个App的时候，Android系统会启动一个Linux Process，该Process包含一个Thread，称为UI Thread或Main Thread。通常一个应用的所有组件都运行在这个Process中，当然，也可以通过修改四大组件的android:process属性指定其运行在不同的Process中。 UI Thread中运行着很多重要的逻辑，如系统事件处理，用户输入事件处理，UI绘制，Service等,如下图 ANRANR：全名Application Not Responding，也就是“应用无响应”，当操作在一段时间内系统无法处理时，系统层面会弹出上图那样的ANR对话框。 为什么会产生ANR在Android里，App的响应能力是由Activity Manager和Window Manager系统服务来监控，通常以下两种情况会报ANR： 5s内无法响应用户输入事件（例如键盘输入、触摸屏幕等） BroadcastReceiver在10s内无法结束 造成以上两种情况的首要原因就是在主线程（UI 线程）里面做了太多的阻塞耗时操作，例如文件读写，数据库读写，网络查询等等。 如何避免ANR知道了ANR发生的原因，那么想要避免ANR，也就很简单了，就一条原则不要在主线程（UI线程）里面做繁重的操作 ANR的处理针对三种不同的情况，一般的处理情况如下 主线程阻塞：开辟单独的子线程来处理耗时阻塞事务 CPU满负荷，I/O阻塞：I/O阻塞一般来说就是文件读写或数据库操作执行在主线程了, 也可以通过开辟子线程的方式异步执行. 内存不够用：增大VM内存, 使用largeHeap属性, 排查内存泄露等. Android 常见启动多线程方式在新线程执行完耗时的逻辑后，往往需要将结果反馈给界面，进行UI更新。Android的UI toolkit不是线程安全的，不能在非UI线程进行UI的更新，所有对界面的更新必须在UI线程进行。 Handler + ThreadAndroid主线程包含一个消息队列（MessageQueue），该消息队列里面可以存入一系列的Message或Runnable对象。通过一个Handler可以往这个消息队列发送Message或者Runnable对象，并且处理这些对象。每次创建一个Handle对象，它会绑定于创建它的线程（也就是UI线程）以及该线程的消息队列，此时，这个handler就会开始把Message或Runnable对象传递到消息队列中，并在它们出队列的时候执行它们。 Handler发送消息队列有两种方式，Post和sendMessage Post方式post允许把一个Runnable对象入消息队列中。123post(Runnable)postAtTime(Runnable,long)postDelayed(Runnable,long) 在这个Runnable对象中，重写run()方法，一般在这个run()方法中更新UI操作1234567handler.post(new Runnable()&#123; @Override public void run()&#123; //此处可更细UI tv.setText(&quot;handler.post 更新ui&quot;) &#125;&#125;); sendMessagesendMessage允许把一个包含消息数据的Message对象发送到消息队列1234sendEmptyMessage(int)sendMessage(Message)sendMessageAtTime(Message,long)sendMessageDelayed(Message,long) 优缺点及适用范围优缺点： Handler用法简单明了，可以将多个异步任务更新UI的代码放在一起，清晰明了 处理单个异步任务代码略多 适用范围 多个异步任务更新UI AsyncTaskAsyncTask是android提供的轻量级的异步类，可以直接继承AsyncTask，在doInBackground()中做耗时操作，onPostExecute()中更新UI。 12345678910111213141516171819202122232425class DownloadTask extends AsyncTask&lt;Integer, Integer, String&gt;&#123; @Override protected void onPreExecute() &#123; //第一个执行方法 super.onPreExecute(); &#125; @Override protected String doInBackground(Integer... params) &#123; //第二个执行方法,onPreExecute()执行完后执行 return &quot;执行完毕&quot;; &#125; @Override protected void onProgressUpdate(Integer... progress) &#123; //这个函数在doInBackground调用publishProgress时触发，虽然调用时只有一个参数 super.onProgressUpdate(progress); &#125; @Override protected void onPostExecute(String result) &#123; //doInBackground返回时触发，换句话说，就是doInBackground执行完后触发 //这里的result就是上面doInBackground执行后的返回值，所以这里是&quot;执行完毕&quot; setTitle(result); super.onPostExecute(result); &#125;&#125; 优缺点及适用范围优缺点： 处理单个异步任务简单，可以获取到异步任务的进度 可以通过cancel方法取消还没执行完的AsyncTask 处理多个异步任务代码显得较多 适用范围： 单个异步任务 ThreadPoolExecutorThreadPoolExecutor提供了一组线程池，可以管理多个线程并行执行。这样可以一方面减少每个并行任务独自建立线程的开销，另一方面可以管理多个并发线程的公共资源，从而提高了多线程的效率。Executors利用工厂模式对ThreadPoolExecutor进行了封装，使用起来更加方便。 Executors提供了四种创建方法： Executors.newFixedThreadPool() 定长线程池 Executors.newCachedThreadPool() 可缓存的线程池，当线程池长度超过了处理的需要，它会灵活回收空闲的线程，当需要增加时，它会灵活增加新的线程，不会对池的长度作任何限制 Executors.newScheduledThreadPool() 定长线程池，支持定时的以及周期性的执行任务，类似Timer Executors.newSingleThreadExecutor() 单线程或的executor，它只创建一个worker线程来执行任务 优缺点及适用范围适用范围： 批处理任务 IntentServiceIntentService继承自Service，是一个经过包装的轻量级Service，用来接收并处理通过Intent传递的异步请求。调用startService（Intent）启动一个IntentService，在onHandleIntent中依次处理顺序过来的请求，处理完后自动结束Service。 特点 可以处理异步任务的简单Service]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Activity启动模式及应用场景]]></title>
    <url>%2F2016%2F04%2F21%2FActivity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E5%8F%8A%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[栈： 程序打开时就创建了一个任务栈，用于存储当前程序的activity。 一个任务栈包含一个activity的集合，去有序的选择哪一个activity和用户进行交互；只有任务栈栈顶的activity才可以跟用户进行交互。 任务栈可以移动到后台，并且保留了每一个activity的状态，并且有序的给用户列出它们的任务，而且还不丢失它们的状态信息。 退出应用程序：当把所有任务栈中的activity清理出栈时，任务栈会被销毁，程序退出。 任务栈的缺点： 没开启一次页面都会在栈顶添加一个activity；只有任务栈中的activity全部被清除出栈时，程序才会退出。 没开启一次页面都会在栈顶添加一个activity，会造成数据冗余，重复数据太多，会导致内存溢出（OOM）。 为了解决任务栈的缺点，引入了启动模式。 启动模式在多个Activity跳转中扮演重要角色，它决定是否生成新的Activity实例；是否重用已存在的Activity实例；是否和其他Activity公用一个task。 task是一个具有栈结构的对象，一个task可以管理多个Activity，启动一个应用，也就创建一个与之对应的task。 四种启动模式 standard singleTop singleTask singleInstance 可直接在AndroidManifest配置android：launcherMode属性。 详细介绍standardstandard是默认的启动模式：每次跳转系统都会在task中生成一个新的Activity实例，放于栈顶standard模式，不管有没有已经存在的实例，都会生成新的实例。 singleTopsingleTop：跳转时如果当前Activity正位于栈顶，则不再生成新的实例（调用onPause,onNewIntent,onResume方法），不位于栈顶或任务栈中没有当前Activity，则生成新的实例。 singleTasksingleTask：如果任务栈中没有要打开的Activity，就生成新的实例；如果任务栈中有要打开的Activity，则使此Activity实例之上的其他Activity实例统统出栈，使此实例成为栈顶对象，显示到幕前。 singleInstancesingleInstance很特别，因为它会启用一个新的栈结构，将Activity放置于新的栈结构中，并保证不再有其他Activity实例进入。新建FirstActivity 启动模式为standard，SecondActivity 启动模式为SingleInstance； 从First跳转到Second时，重新启用了一个新的栈结构，来放置Second实例，然后按下返回键，再次回到原始栈机构；图中下部分在Second再次跳转到First，这时系统会在原始栈结构中生成一个First实例，然后后退两次，此时并没有退出，而是到了Second？？？是因为从Second跳转到First的时候，起点变成了Second所在的栈结构。 应用场景SingleTop：适合接受通知启动的内容显示页面。SingleTask：适合做为程序入口。SingleInstance：适合需要与程序分离开的页面。例如闹钟提醒，将闹钟提醒和闹钟设置分离。]]></content>
      <categories>
        <category>Android</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计的五个基本原则]]></title>
    <url>%2F2016%2F04%2F16%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%BA%94%E4%B8%AA%E5%9F%BA%E6%9C%AC%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[面向对象设计的3个基本要素：封装、继承、多态 面向对象设计的5个基本原则：单一职责原则、开放封闭、里氏置换、依赖倒置、接口隔离 单一职责原则（Single-Resposibility Principle）其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而大大损伤其内聚性和耦合度。通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。专注，是一个人优良的品质；同样的，单一也是一个类的优良设计。交杂不清的职责将使得代码看起来特别别扭牵一发而动全身，有失美感和必然导致丑陋的系统错误风险。 开放封闭原则（Open-Closed principle）其核心思想是：软件实体应该是可扩展的，而不是可修改的。也就是说对扩展开放，对修改封闭。1、对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。2、对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。实现开开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。“需求总是变化”没有不变的软件，所以就需要用封闭开放原则来封闭变化满足需求，同时还能保持软件内部的封装体系稳定，不被需求的变化影响。 里氏置换原则（Liskov-Substituion Principle）其核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。Liskov替换原则，主要着眼于对抽象和多态建立在继承的基础上，因此只有遵循了Liskov替换原则，才能保证继承复用是可靠地。实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。Liskov替换原则是关于继承机制的设计原则，违反了Liskov替换原则就必然导致违反开放封闭原则。Liskov替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。 依赖倒置原则（Dependecy-Inversion Principle）其核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。 接口隔离原则（Interface-Segregation Principle）其核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。 总结以上就是5个基本的面向对象设计原则，它们就像面向对象程序设计中的金科玉律，遵守它们可以使我们的代码更加鲜活，易于复用，易于拓展，灵活优雅。不同的设计模式对应不同的需求，而设计原则则代表永恒的灵魂，需要在实践中时时刻刻地遵守。就如ARTHUR J.RIEL在那边《OOD启示录》中所说的：“你并不必严格遵守这些原则，违背它们也不会被处以宗教刑罚。但你应当把这些原则看做警铃，若违背了其中的一条，那么警铃就会响起。”]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java 线程同步]]></title>
    <url>%2F2016%2F04%2F09%2Fjava-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[为什么要线程同步？当我们有多个线程同时访问一个变量或对象时，如果这些线程中既有读又有写操作时，会导致变量值或对象的状态出现混乱，从而导致程序异常。比如：银行账户存钱取钱 同步方法用synchroized关键字修饰方法。1234567891011121314151617181920public class Bank &#123; private int count =0;//账户余额 //存钱 public synchronized void addMoney(int money)&#123; count +=money; System.out.println(System.currentTimeMillis()+&quot;存进：&quot;+money); &#125; //取钱 public synchronized void subMoney(int money)&#123; if(count-money &lt; 0)&#123; System.out.println(&quot;余额不足&quot;); return; &#125; count -=money; System.out.println(+System.currentTimeMillis()+&quot;取出：&quot;+money); &#125;&#125; 补充：synchroized也可以修饰静态方法，会锁住整个类 同步代码块1234567891011public class Bank &#123; private int count =0;//账户余额 //存钱 public void addMoney(int money)&#123; synchroized(this)&#123; count +=money; &#125; System.out.println(System.currentTimeMillis()+&quot;存进：&quot;+money); &#125;&#125; 效果和同步方法差不多。 注：同步是一种高开销操作，因此应该尽量减少同步的内容。通常没有必要同步整个方法，使用synchorized同步代码块即可。 使用特殊域变量 Volatile volatile关键字为域变量的访问提供一种免锁机制 使用volatile修饰相当于告诉虚拟机该域可能会被其他线程更新 每次使用该域就要重新计算，而不是使用寄存器中的值 volatile不会提供任何原子操作，它也不能用来修饰final类型的变量 123456789public class Bank &#123; private volatile int count =0;//账户余额 //存钱 public synchronized void addMoney(int money)&#123; count +=money; System.out.println(System.currentTimeMillis()+&quot;存进：&quot;+money); &#125;&#125; 重入锁在java 5中新增了一个包java.util.concurrent包来支持同步。ReentrantLock类是可重入、互斥、实现了Lock接口的锁，它与使用synchroized方法和块具有相同的基本行为和语义，并且扩展了其能力。 ReentrantLock类的常用方法：ReentrantLock()：创建一个ReentrantLock实例lock()：获得锁unlock()：释放锁 123456789101112131415161718public class Bank &#123; private int count =0;//账户余额 //声明锁 private ReentrantLock lock = new ReentrantLock(); //存钱 public synchronized void addMoney(int money)&#123; lock.lock();//上锁 try&#123; count +=money; System.out.println(System.currentTimeMillis()+&quot;存进：&quot;+money); &#125; finally &#123; lock.unlock();//解锁 &#125; &#125;&#125; 要及时释放锁，否则会出现死锁。如果synchroized能满足用户需求，就用synchroized，因为它能简化代码。 使用局部变量(ThreadLocal)1234567891011121314151617public class Bank &#123; private static ThreadLocal&lt;Integer&gt; count = new ThreadLocal&lt;Integer&gt;()&#123; @Override protected Integer initialValue() &#123; // TODO Auto-generated method stub return 0; &#125; &#125;; //存钱 public void addMoney(int money) &#123; count.set(count.get() + money); System.out.println(System.currentTimeMillis() + &quot;存进：&quot; + money); &#125;&#125; 使用局部变量，则每个使用该变量的线程都获得该变量的副本，副本之间相互独立，这样每一个线程都可以随意修改自己的变量副本，而不会对其它线程产生影响。 总结ThreadLocal和同步机制区别 ThreadLocal与同步机制都是为了解决多线程中相同变量的访问冲突问题 前者采用以“空间换时间”的方法，后者采用以“时间换空间”的方法]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java 多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[标签（tags）使用]]></title>
    <url>%2F2015%2F12%2F01%2F%E6%A0%87%E7%AD%BE%EF%BC%88tags%EF%BC%89%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[标签（tags）使用教程 1.新建页面，命名为tags；1hexo new page &quot;tags&quot; 2.编辑刚新建的页面（source/tags/index.md），将页面的类型设置为tags，主题将自动为这个页面显示标签云；123title: tagsdate: 2017-10-31 12:26:42type: &quot;tags&quot;//这里 *注意：如果有启用多说或Disqus评论，默认页面也会带有评论。需要关闭的话，请添加字段comments并将其值设置为false，如：1234title: tagsdate: 2017-10-31 12:26:42type: &quot;tags&quot;comments: false//这里 3.在菜单中添加链接。编辑主题配置文件，添加tags到menu中；12345menu: 首页: / || home 标签: /tags/ || tags //这里 归档: /archives/ || archive 关于: /about/ || user]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo图片无法显示]]></title>
    <url>%2F2015%2F11%2F06%2Fhexo%E5%9B%BE%E7%89%87%E6%97%A0%E6%B3%95%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[在使用Hexo搭建个人博客的过程中，发现使用链接（！[描述]（图片无法显示/t1.png））的方式引用图片，无法显示，如下 解决方法1.设置站点配置 _config.yml1post_asset_folder: true 2.安装插件1npm install hexo-asset-image --save 3.引用图片1（！[描述]（图片无法显示/t1.png）） 4.hexo server123npm install //可能需要hexo d //本地部署hexo s //本地预览]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 引用图片]]></title>
    <url>%2F2015%2F11%2F05%2Fhexo-%E5%BC%95%E7%94%A8%E5%9B%BE%E7%89%87%2F</url>
    <content type="text"><![CDATA[hexo可通过插件引用图片 hexo-asset-image.新建文章：1hexo new &quot;hexo-引用图片&quot; 在source/_posts目录下会生成“hexo-引用图片”文件夹和“hexo-引用图片.md”文件，文件夹中存放图片（test.jpg）。 安装1npm install hexo-asset-image --save 引用1![描述信息](hexo-引用图片/test.jpg)]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo+next添加algolia搜索]]></title>
    <url>%2F2015%2F11%2F05%2Fhexo-next%E6%B7%BB%E5%8A%A0algolia%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[当博客达到一定数量的时候，为了方便找到想找的内容，就需要用到搜索了。 效果图 开始添加 下载最新的next主题（5.1.0），因为最新版的已经集成了algolia搜索，可以省去很多配置和修改。 去algolia官网注册账号（可直接使用github账号登录） 新建index 打开API Keys页面，里面的信息等会需要写到hexo的配置文件中 在根目录的站点配置文件_config.yml中加入如下配置，参照上图申请到的key值 1234567891011algolia: appId: &apos;appid&apos; apiKey: &apos;apiKey&apos; adminApiKey: &apos;adminApiKey&apos; indexName: &apos;上面填写的index名&apos; chunkSize: 5000 fields: - title - slug - path - content:strip 执行hexo algolia. 查看algolia -&gt; Indices如果无法提交成功，先执行hexo clean即可。 在\themes\next下找到_config.yml，找到如下内容，将enable修改为true，labels修改为自己需要的 123456789# Algolia Searchalgolia_search: enable: true hits: per_page: 10 labels: input_placeholder: &quot;输入关键字&quot; hits_empty: &quot;没有找到与「$&#123;query&#125;」相关的内容&quot; hits_stats: &quot;$&#123;hits&#125;条相关记录，共耗时 $&#123;time&#125; ms&quot; 在themes\next\layout_partials中找到header.swig，找到以下代码并修改 123456789algolia: &#123; &lt;!-- applicationID: &apos;&#123;&#123; theme.algolia.applicationID &#125;&#125;&apos;,--&gt; &lt;!-- 改为 (对应站点配置_config.yml中的algolia.appId)--&gt; applicationID: &apos;&#123;&#123; theme.algolia.applicationID &#125;&#125;&apos;, apiKey: &apos;&#123;&#123; theme.algolia.apiKey &#125;&#125;&apos;, indexName: &apos;&#123;&#123; theme.algolia.indexName &#125;&#125;&apos;, hits: &#123;&#123; theme.algolia_search.hits | json_encode &#125;&#125;, labels: &#123;&#123; theme.algolia_search.labels | json_encode &#125;&#125;&#125; algolia刷新添加了新文章，搜索不到时需要刷新algolia1hexo algolia 如果失败，clean一下1hexo clean 然后再执行 hexo algolia]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo常用命令]]></title>
    <url>%2F2015%2F10%2F30%2Fhexo%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[本文介绍hexo的常用命令。 hexonpm install hexo -g #安装npm update hexo -g #升级npm init #初始化 服务器hexo s #启动服务预览并自动更新，无需重启服务器hexo server -s #静态模式hexo server -p 5000 #更改端口hexo server -i 192.168.1.1 #自定义IPhexo clean #清理缓存hexo g #生成静态网页hexo d #开始部署 hexo g -d #生成静态网页并部署，两步并一步 草稿hexo publish [layout] 模版hexo new “postName” #新建文章hexo new page “pageName” #新建页面hexo server #启动服务预览hexo generate #生成静态页面hexo deploy #部署 简写hexo n “我的博客” == hexo new “我的博客” #新建文章hexo g == hexo generate #生成hexo s == hexo server #启动服务预览hexo d == hexo deploy #部署 设置文章摘要 报错error:ERROR Deployer not found: git解决方法npm install hexo-deployer-git –save]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
